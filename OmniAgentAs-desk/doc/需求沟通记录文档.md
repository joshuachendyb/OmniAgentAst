# OmniAgentAst. 桌面版 - 需求沟通记录文档

**【版本】v1.0 : 2026-02-15 11:44:16 : 创建文档**

---

## 1. 文档说明

### 1.1 文档目的

本文档用于记录 OmniAgentAst. 桌面版项目开发前的需求沟通、技术选型确认、功能边界界定等关键决策事项。所有议题需经讨论确认后方可进入开发阶段。

### 1.2 使用方式

- **议题状态标记**：每个议题后标注当前状态
  - 【待讨论】：尚未讨论确认
  - 【讨论中】：正在进行讨论
  - 【已确认】：双方达成一致
  - 【待定】：暂时搁置，后续再议
  
- **决策记录**：每个议题下记录讨论结论和决策依据

### 1.3 沟通原则

1. **关键阻塞项必须先确认**：标记为"阻塞开发"的议题必须在编码前确定
2. **灵活项可边做边定**：非阻塞项可在开发过程中逐步明确
3. **变更需记录**：已确认事项如需变更，需更新版本号并说明原因

---

## 2. 产品定位与范围议题

### 2.1 目标用户定义 【已确认】【阻塞开发】

**议题描述**：
明确产品的核心目标用户群体，这将直接影响功能设计、交互方式和技术选型。

**可选方案**：

| 用户类型 | 技术能力 | 核心需求 | 设计重点 |
|---------|---------|---------|---------|
| **程序员/开发者** | 高 | 自动化脚本、开发辅助 | 命令行支持、扩展性 |
| **办公效率族** | 中 | 文件整理、批量处理 | 可视化操作、快捷方式 |
| **电脑小白** | 低 | 简化操作、自然语言 | 零学习成本、强引导 |
| **全人群通用** | 混合 | 全能助手 | 自适应界面、分层功能 |

**需要确认的问题**：
1. 主要面向哪类用户？（单选/多选）
2. 用户的技术水平预期如何？
3. 是否需要考虑无障碍访问？

**讨论记录**：
- **日期**: 2026-02-15 11:44:16
- **决策结果**: **B + C + D**（办公效率族 + 电脑小白 + 全人群通用）
- **决策依据**: 
  1. 以办公效率族为核心用户（重复性工作多，愿意使用工具）
  2. 通过自然语言交互降低小白用户门槛
  3. 设计自适应界面，根据用户行为调整功能展示
- **产品策略**: 
  - 自然语言作为主要交互方式（照顾小白）
  - 提供快捷操作和批量处理（照顾办公族）
  - 支持分层功能展示，隐藏高级功能（自适应）
- **多语言策略**: 【已确认】中文为主，英文界面，多语言架构，MVP预留接口后续扩展

---

### 2.2 核心使用场景 【已确认】【阻塞开发】

**议题描述**：
确定产品的功能范围和优先级策略。经讨论，采用"场景驱动"而非"固定优先级"策略。

**候选场景清单**：

**A. 文件管理类**
- A1: 自动整理桌面/下载文件夹（按类型/日期分类）
- A2: 批量重命名文件（智能识别内容）
- A3: 查找重复文件/大文件清理
- A4: 文件内容搜索与摘要

**B. 系统控制类**
- B1: 批量打开/关闭指定软件
- B2: 窗口管理（快速切换、分屏、截图）
- B3: 系统信息查询（CPU/内存/磁盘）
- B4: 定时任务（关机/提醒/执行脚本）

**C. 浏览器自动化**
- C1: 自动填表/登录常用网站
- C2: 批量下载网页资源
- C3: 网页内容提取与保存
- C4: 自动化测试脚本

**D. 知识管理类**
- D1: 本地文档索引与搜索
- D2: 剪贴板历史管理
- D3: 笔记自动整理与关联
- D4: 待办事项智能提醒

**E. 效率工具类**
- E1: 文本快速处理（格式化/翻译/总结）
- E2: 二维码/条形码生成识别
- E3: 图片批量处理（压缩/格式转换/OCR）
- E4: 密码/敏感信息管理

**需要确认的问题**：
1. 从以上候选场景中，选出最优先的3个场景
2. 是否有特定场景不在列表中？
3. 是否需要支持定时任务/自动化脚本编排？

**讨论记录**：
- **日期**: 2026-02-15 12:00:00
- **核心思路**: **工作与事情处理导向，场景驱动，无固定优先级**
- **决策结果**:
  - 不预设功能优先级（A/B/C/D/E 无先后之分）
  - 根据用户具体的"工作/事情处理"场景，动态调用所需工具
  - AI根据用户意图自动判断需要哪些能力组合
- **示例场景**:
  | 用户场景 | 涉及工具类别 | 具体工具 |
  |---------|-------------|---------|
  | "整理桌面并截图发邮件" | A(文件) + B(截图) + C(邮件) | 文件整理、窗口截图、浏览器自动化 |
  | "找昨天的会议记录并总结" | A(搜索) + D(知识库) | 文件搜索、文档理解、内容摘要 |
  | "批量处理下载的图片" | A(文件) + E(图片) | 文件批量操作、图片压缩/格式转换 |
  | "打开IDE并继续昨天的项目" | B(系统控制) + D(工作区恢复) | 启动软件、窗口布局、历史记录 |
- **实现策略**:
  - MVP阶段实现基础工具集（覆盖A/B/C/D/E各至少1-2个核心工具）
  - 通过AI Intent识别，自动组合工具完成复杂任务
  - 不限制用户使用场景，由用户工作流决定功能组合
- **MVP工具覆盖目标**:
  - ✅ A类: 文件操作（读/写/移动/整理）
  - ✅ B类: 窗口管理（列出/切换/截图）
  - ✅ C类: 浏览器基础（打开/点击/输入）
  - ✅ D类: 剪贴板/搜索（读写剪贴板、本地搜索）
  - ✅ E类: 文本处理（格式转换、简单处理）

---

### 2.3 软件集成需求 【待讨论】【非阻塞】

**议题描述**：
是否需要与特定第三方软件深度集成。

**候选集成软件**：
- 开发工具：VSCode、JetBrains系列、Git
- 办公软件：Microsoft Office、WPS、Notion
- 浏览器：Chrome、Edge、Firefox
- 通讯工具：微信、钉钉、飞书
- 其他：Obsidian、Everything、Listary

**需要确认的问题**：
1. 必须集成哪些软件？
2. 集成深度？（简单调用？深度API对接？）
3. 是否支持插件式扩展集成？

**建议决策**：
> MVP阶段不深度集成特定软件，提供通用工具接口，后续通过插件扩展

---

## 3. 技术架构议题

### 3.1 桌面技术栈选择 【待讨论】【阻塞开发】

**议题描述**：
选择桌面端UI框架，这是影响开发效率、产品体验和部署方式的关键决策。

**技术选型对比**：

| 技术方案 | 开发效率 | 性能表现 | 包体大小 | 学习成本 | 生态成熟度 |
|---------|---------|---------|---------|---------|-----------|
| **Tauri (Rust)** | 中 | 极高 | 极小(~3MB) | 高(需学Rust) | 新兴(快速发展) |
| **Electron** | 高 | 中 | 大(~100MB+) | 低(Web技术) | 非常成熟 |
| **PyQt/PySide** | 中 | 高 | 中(~30MB) | 中 | 成熟稳定 |
| **PyWebView** | 高 | 中 | 小(~10MB) | 低 | 轻量但功能有限 |
| **原生Win32/WPF** | 低 | 极高 | 小 | 高 | 成熟但开发慢 |

**各方案详细分析**：

**方案A: Tauri**
- 优点：Rust底层性能极佳、包体极小、内存占用低、安全沙箱
- 缺点：需学习Rust、生态相对较新、某些系统API调用复杂
- 适用：追求极致性能和小体积

**方案B: Electron**
- 优点：Web技术栈、生态丰富、开发快速、跨平台成熟
- 缺点：包体大、内存占用高、启动慢
- 适用：快速开发、功能复杂、团队熟悉Web

**方案C: PyQt/PySide**
- 优点：Python原生、功能全面、性能良好、文档完善
- 缺点：界面风格偏传统、跨平台打包复杂、GPL/LGPL协议注意
- 适用：Python团队、功能型应用

**方案D: PyWebView**
- 优点：极简方案、Python+HTML混合、包体小
- 缺点：功能受限、生态薄弱、复杂交互难实现
- 适用：快速原型、简单工具

**需要确认的问题**：
1. 优先考虑哪个维度？（性能/体积/开发速度/团队技能）
2. 团队技术栈倾向？（Rust/Web/Python/C#）
3. 对安装包大小的容忍度？（<10MB/<50MB/<100MB/无所谓）

**建议决策**：
> 推荐使用 **Tauri**，理由：
> 1. 桌面端小体积是竞争优势
> 2. 前端用React/Vue开发效率高
> 3. Python作为后端服务通过IPC通信
> 4. 符合现代桌面应用趋势

---

### 3.2 Python后端部署方式 【待讨论】【阻塞开发】

**议题描述**：
确定Python后端的交付形式，影响用户安装体验和开发复杂度。

**可选方案**：

**方案A: PyInstaller打包成独立exe**
```
优点：
- 用户零配置，双击运行
- 不依赖系统Python环境
- 避免版本冲突

缺点：
- 打包体积大（+50-100MB）
- 启动速度较慢（解压过程）
- 杀毒软件可能误报
- 打包过程复杂，易出错
```

**方案B: 要求用户安装Python**
```
优点：
- 安装包极小（仅代码<10MB）
- 启动速度快
- 易于更新（替换文件即可）
- 开发者友好

缺点：
- 用户需先装Python 3.11+
- 可能遇到环境配置问题
- 非技术用户门槛高
```

**方案C: 内嵌Python解释器（ embeddable python）**
```
优点：
- 无需用户安装Python
- 包体适中（+20-30MB）
- 环境隔离，避免冲突
- 启动速度可接受

缺点：
- 首次安装需下载解释器
- 需要自定义安装脚本
- 跨平台打包复杂
```

**方案D: 混合方案（安装时检测）**
```
优点：
- 自动检测系统Python
- 有则用，无则自动安装
- 最佳用户体验

缺点：
- 安装程序开发复杂
- 需要处理多种情况
```

**需要确认的问题**：
1. 目标用户是否能接受安装Python？
2. 对安装包大小的硬性要求？
3. 优先开发效率还是用户便利性？

**建议决策**：
> 推荐 **方案C（内嵌Python）**，理由：
> 1. 平衡了体积和便利性
> 2. 可精确控制Python版本和依赖
> 3. 避免与用户现有Python环境冲突
> 4. 更新机制简单（替换内嵌目录）

---

### 3.3 AI模型接入策略 【待讨论】【阻塞开发】

**议题描述**：
确定AI模型提供商、接入方式、API Key管理策略。

**模型选择**：

**主模型（必选其一）**：
- [ ] **Claude 3.5 Sonnet**（Anthropic）
  - 优点：工具调用能力强、上下文长(200K)、理解准确
  - 缺点：国内访问需代理、价格较高
  
- [ ] **GPT-4/GPT-4o**（OpenAI）
  - 优点：功能全面、生态丰富、速度快
  - 缺点：国内访问困难、Function Calling有学习成本

- [ ] **国产模型**（通义千问/文心一言/智谱）
  - 优点：国内访问稳定、中文优化好
  - 缺点：Function Calling支持不一、功能可能受限

**备用模型（可选）**：
- [ ] **本地模型**（Llama 3/ChatGLM/Qwen）
  - 优点：完全离线、隐私安全、无API费用
  - 缺点：性能依赖硬件、配置复杂、效果可能不如云端

**API Key管理方式**：

**方式A: 配置文件明文存储**
```yaml
ai:
  provider: anthropic
  api_key: "sk-xxx"  # 明文
```
- 优点：简单直接
- 缺点：不安全，可能被窃取

**方式B: 系统密钥管理**
- Windows: Credential Manager
- macOS: Keychain
- Linux: Secret Service
- 优点：系统级安全
- 缺点：实现复杂，跨平台差异大

**方式C: 环境变量**
```bash
export ANTHROPIC_API_KEY="sk-xxx"
```
- 优点：不提交到代码库
- 缺点：用户需手动配置，重启后失效

**方式D: 加密存储+主密码**
- 首次启动设置主密码
- API Key用主密码加密存储
- 优点：安全性高
- 缺点：用户需记主密码

**需要确认的问题**：
1. 首选AI模型提供商？
2. 是否需要支持多模型切换？
3. API Key安全要求级别？
4. 是否考虑本地模型作为离线备份？

**建议决策**：
> 1. **主模型**: Claude 3.5 Sonnet（工具调用能力强）
> 2. **备用**: 支持OpenAI作为备选
> 3. **Key管理**: 方案D（加密存储+主密码）
> 4. **本地模型**: Phase 2再考虑

---

## 4. 核心功能设计议题

### 4.1 混合架构执行策略 【待讨论】【阻塞开发】

**议题描述**：
细化Plan-and-Execute + ReAct + Reflection三层架构的具体执行策略。

**议题4.1.1: Planner生成计划的确认机制**

**可选策略**：

**策略A: 总是确认**
- 每个计划生成后都显示给用户
- 用户点击[执行]后才继续
- 优点：完全可控，不会误操作
- 缺点：频繁打断，体验差

**策略B: 智能判断**
```python
if risk_level == "low" and user_trust_high:
    auto_execute()
else:
    ask_confirmation()
```
- 低风险+高信任度用户 → 自动执行
- 其他情况 → 请求确认
- 优点：平衡效率和安全
- 缺点：判断逻辑复杂

**策略C: 白名单机制**
- 用户预设"自动执行"的操作类型
- 如："整理桌面"可自动，"删除文件"需确认
- 优点：用户自定义程度高
- 缺点：配置门槛高

**策略D: 学习模式**
- 首次使用总是确认
- 学习用户习惯，逐步自动执行熟悉的操作
- 优点：个性化，越用越顺手
- 缺点：实现复杂，需AI学习

**需要确认的问题**：
1. 默认采用哪种策略？
2. 是否允许用户切换策略？
3. "高信任度用户"如何定义？

**建议决策**：
> 推荐 **策略B（智能判断）**，MVP阶段简化实现：
> - 读取操作 → 自动执行
> - 写入操作 → 请求确认
> - 删除操作 → 必须确认

---

**议题4.1.2: Executor重试机制参数**

**需要确认的参数**：

| 参数 | 候选值 | 说明 |
|------|-------|------|
| **最大重试次数** | 2/3/5 | 单次步骤失败后的重试次数 |
| **重试间隔** | 0.5s/1s/2s | 每次重试的等待时间 |
| **超时时间** | 10s/30s/60s | 单个步骤的最大执行时间 |
| **失败后策略** | 跳过/终止/转Refiner | 重试用尽后的处理方式 |

**需要确认的问题**：
1. 各参数的默认值？
2. 是否允许用户自定义？
3. 重试时是否增加随机延迟？（避免被反爬虫）

**建议决策**：
> - 最大重试次数：3次
> - 重试间隔：1秒
> - 超时时间：30秒
> - 失败后：转Refiner分析

---

**议题4.1.3: Refiner触发条件与策略**

**触发条件选项**：

**条件A: 连续失败次数**
- 同一步骤连续失败N次触发Refiner
- N = ?（2次？3次？）

**条件B: 用户明确反馈**
- 用户点击"不对"/"重试"按钮
- 主动触发深度分析

**条件C: 异常检测**
- 结果与预期差异过大
- 返回内容包含错误关键字

**条件D: 超时**
- 步骤执行时间远超预期

**Refiner处理策略**：

**策略1: 内省修复**
- AI自我分析失败原因
- 生成修复方案重新执行
- 优点：自动化
- 缺点：可能再次失败

**策略2: 降级执行**
- 复杂操作降级为简单操作
- 如：批量操作改为逐个操作
- 优点：提高成功率
- 缺点：效率降低

**策略3: 用户协助**
- AI分析后询问用户
- "可能需要管理员权限，是否以管理员重启？"
- 优点：精准解决问题
- 缺点：打断用户

**需要确认的问题**：
1. Refiner触发条件组合？
2. 采用哪种处理策略？
3. Refiner尝试次数上限？

**建议决策**：
> - 触发条件：连续失败2次 **或** 用户反馈
> - 处理策略：策略1 → 策略3（先自动，后求助）
> - 最大尝试：Refiner最多介入2次

---

### 4.2 工具实现范围 【待讨论】【部分阻塞】

**议题4.2.1: MVP阶段工具清单**

**必须实现（阻塞开发）**：

| 工具类别 | 具体工具 | 功能说明 | 优先级 |
|---------|---------|---------|--------|
| **文件操作** | read_file | 读取文件内容 | P0 |
| | write_file | 写入文件 | P0 |
| | list_directory | 列出目录内容 | P0 |
| | move_file | 移动/重命名文件 | P0 |
| | delete_file | 删除文件（需确认） | P0 |
| **系统信息** | get_system_info | 获取系统状态 | P1 |
| | run_shell | 执行shell命令（受限） | P1 |
| **窗口管理** | list_windows | 列出所有窗口 | P1 |
| | switch_window | 切换到指定窗口 | P1 |
| | screenshot | 截图 | P1 |
| **剪贴板** | clipboard_read | 读取剪贴板 | P2 |
| | clipboard_write | 写入剪贴板 | P2 |

**后续实现（非阻塞）**：

| 工具类别 | 具体工具 | 功能说明 | 计划阶段 |
|---------|---------|---------|---------|
| **浏览器** | browser_navigate | 打开网页 | Phase 2 |
| | browser_click | 点击元素 | Phase 2 |
| | browser_input | 输入文本 | Phase 2 |
| **键鼠模拟** | type_text | 模拟键盘输入 | Phase 2 |
| | press_key | 按键 | Phase 2 |
| | mouse_click | 鼠标点击 | Phase 2 |
| **知识库** | index_document | 索引文档 | Phase 2 |
| | search_knowledge | 搜索知识 | Phase 2 |

**需要确认的问题**：
1. MVP工具清单是否完整？
2. 是否有遗漏的必备工具？
3. 各工具的实现顺序？

---

**议题4.2.2: Shell命令执行安全策略**

**安全级别选项**：

**级别1: 白名单制**
```python
ALLOWED_COMMANDS = [
    "ls", "dir", "cat", "type",
    "mkdir", "rmdir",
    "copy", "cp", "move", "mv",
    "echo", "ping"
]
```
- 只允许白名单内的命令
- 优点：最安全
- 缺点：功能受限

**级别2: 黑名单制**
```python
BLOCKED_PATTERNS = [
    r"rm\s+-rf\s+/",
    r"format\s+",
    r"mkfs\.",
    r">\s*/dev/",
    r"dd\s+if=.*of=/dev"
]
```
- 禁止危险命令，其他允许
- 优点：灵活性好
- 缺点：可能有漏网之鱼

**级别3: 沙箱执行**
- 在Docker/虚拟机中执行命令
- 优点：完全隔离
- 缺点：性能开销大，配置复杂

**级别4: 用户确认制**
- 所有shell命令执行前必须用户确认
- 优点：简单直接
- 缺点：频繁打断

**需要确认的问题**：
1. 采用哪种安全级别？
2. 是否允许用户调整安全级别？
3. 危险操作如何定义？

**建议决策**：
> 采用 **级别2（黑名单）+ 用户确认** 组合：
> - 黑名单自动拦截极度危险操作
> - 修改类操作需用户确认
> - 读取类操作自动执行

---

## 5. 用户体验设计议题

### 5.1 界面形态设计 【待讨论】【阻塞开发】

**议题5.1.1: 主界面形式**

**可选方案**：

**方案A: 聊天对话框形式**
```
┌─────────────────────────────┐
│ OmniAgentAst.           [_]│
├─────────────────────────────┤
│                             │
│  🤖: 有什么可以帮你的？      │
│                             │
│  👤: 帮我整理桌面           │
│                             │
│  🤖: 好的，我发现了...       │
│      [执行] [取消]          │
│                             │
│  ┌─────────────────────┐   │
│  │ 输入消息...         │   │
│  └─────────────────────┘   │
└─────────────────────────────┘
```
- 优点：直观、用户熟悉
- 缺点：空间利用率低

**方案B: IDE式布局**
```
┌────────┬──────────────────┐
│ 工具箱  │    主工作区      │
│        │                  │
├────────┤                  │
│ 历史   │                  │
│ 记录   │                  │
├────────┤                  │
│ 快捷   │                  │
│ 指令   │                  │
└────────┴──────────────────┘
```
- 优点：功能分区清晰
- 缺点：界面复杂，学习成本高

**方案C: 命令面板形式**
- 类似VSCode命令面板/Alfred
- 快捷键唤出，输入指令
- 优点：极简、高效
- 缺点：不适合复杂交互

**方案D: 悬浮球+对话框**
- 桌面悬浮球常驻
- 点击展开对话窗口
- 优点：随时可用，不占用任务栏
- 缺点：可能被其他窗口遮挡

**需要确认的问题**：
1. 首选哪种界面形式？
2. 是否支持界面切换？
3. 窗口大小和位置策略？

**建议决策**：
> 推荐 **方案A（聊天对话框）+ 方案D（系统托盘）** 组合：
> - 主窗口：聊天对话形式
> - 后台：系统托盘常驻
> - 支持全局快捷键快速唤起

---

**议题5.1.2: 交互模式细节**

**议题A: 确认对话框设计**

**示例场景**：
```
用户：帮我整理桌面

Agent准备执行：
┌─────────────────────────────┐
│ 📋 执行计划                    │
├─────────────────────────────┤
│ 步骤1: 扫描桌面文件 ✓         │
│ 步骤2: 分类文件                │
│   - 移动 15个图片 → 截图/     │
│   - 移动 8个文档 → 文档/      │
│ 步骤3: 清理空文件夹            │
├─────────────────────────────┤
│ 预计耗时: 5秒                 │
│ 涉及文件: 23个                │
├─────────────────────────────┤
│ [查看详情] [执行] [修改] [取消]│
└─────────────────────────────┘
```

**需要确认的问题**：
1. 确认对话框的详细程度？
2. 是否显示预估时间和影响范围？
3. "修改"按钮是否允许用户调整计划？

---

**议题B: 静默执行范围**

**建议分级**：

| 操作类型 | 风险等级 | 执行方式 |
|---------|---------|---------|
| 读取文件/查询信息 | 🟢 低 | 静默执行 |
| 创建文件夹/复制文件 | 🟡 中 | 通知用户，不弹窗确认 |
| 移动文件/修改配置 | 🟠 中高 | 显示确认对话框 |
| 删除文件/执行命令 | 🔴 高 | 必须确认 |
| 系统级操作 | ⚫ 极高 | 禁止自动，需管理员确认 |

**需要确认的问题**：
1. 各操作类型的风险分级是否合理？
2. 是否允许用户自定义风险分级？
3. 通知方式？（弹窗/托盘提示/仅记录）

---

### 5.2 错误处理与恢复 【待讨论】【非阻塞】

**议题5.2.1: 错误反馈机制**

**需要定义的要素**：

**A. 错误展示方式**
- 方式1: 弹窗提示（强制关注）
- 方式2: 聊天窗口内显示（非打断）
- 方式3: 系统通知（托盘气泡）
- 方式4: 仅记录日志（用户主动查看）

**B. 错误信息详细程度**
```
简洁版: "操作失败，请重试"
标准版: "无法移动文件: 权限不足"
详细版: "无法移动文件 'test.txt' 到 'backup/': 
        权限不足 (Error 5)
        建议: 以管理员身份运行或检查文件权限"
```

**C. 错误恢复选项**
- [ ] 重试
- [ ] 跳过此步骤
- [ ] 终止任务
- [ ] 查看帮助文档
- [ ] 报告问题

**需要确认的问题**：
1. 不同错误类型的展示方式？
2. 默认错误信息详细程度？
3. 是否提供"一键修复"建议？

---

**议题5.2.2: 撤销功能设计**

**技术难点**：
- 文件删除难以真正撤销（需回收站/备份）
- 命令执行后难以回退
- 窗口操作不可逆

**可选策略**：

**策略A: 操作日志+手动恢复**
- 记录所有操作日志
- 提供"逆向操作"指南
- 用户手动执行恢复

**策略B: 沙箱预览**
- 执行前生成"预览报告"
- 用户确认后再真正执行
- 优点：零风险
- 缺点：效率降低

**策略C: 自动备份**
- 修改前自动备份原文件
- 提供"恢复到之前状态"功能
- 优点：真正可撤销
- 缺点：占用存储空间

**需要确认的问题**：
1. 是否需要撤销功能？
2. 哪些操作支持撤销？
3. 采用哪种策略？

**建议决策**：
> MVP阶段采用 **策略B（沙箱预览）+ 策略A（操作日志）**：
> - 关键操作先预览再执行
> - 记录日志便于手动恢复
> - Phase 2考虑自动备份

---

## 6. 数据与配置议题

### 6.1 数据存储策略 【待讨论】【阻塞开发】

**议题6.1.1: 对话历史存储**

**存储范围**：
- A) 仅当前会话（重启清空）
- B) 最近N条（如最近100条）
- C) 全部历史（按日期归档）
- D) 用户自定义

**存储位置**：
```
Windows: %APPDATA%/OmniAgentAst/conversations/
macOS:   ~/Library/Application Support/OmniAgentAst/
Linux:   ~/.config/OmniAgentAst/
```

**存储格式**：
- 格式A: SQLite数据库（推荐）
- 格式B: JSON文件（易读但性能差）
- 格式C: 纯文本日志（最简单）

**隐私选项**：
- [ ] 允许用户关闭历史记录
- [ ] 敏感操作不记录（如密码输入）
- [ ] 定期自动清理（如30天前）

**需要确认的问题**：
1. 默认存储范围？
2. 存储格式选择？
3. 历史记录的隐私处理？

**建议决策**：
> - 存储范围：最近100条会话 + 用户收藏的重要对话
> - 存储格式：SQLite
> - 默认开启，可关闭
> - 敏感信息自动脱敏

---

**议题6.1.2: 配置文件设计**

**配置文件格式**：

**候选格式**：
- **YAML**: 人类可读，支持注释，推荐
- **JSON**: 通用但无注释，难读
- **TOML**: 介于两者之间，较新
- **INI**: 简单，配置项少时可用

**配置项分类**：

```yaml
# config.yaml 结构示例
version: "1.0"

# AI配置
ai:
  provider: "anthropic"  # anthropic | openai
  model: "claude-3-5-sonnet-20241022"
  api_key_encrypted: "base64_encoded_encrypted_key"
  
# 界面配置
ui:
  theme: "auto"  # light | dark | auto
  language: "zh-CN"
  font_size: 14
  window_position: "center"
  minimize_to_tray: true
  global_shortcut: "Ctrl+Shift+O"

# 安全设置
security:
  confirm_destructive: true
  shell_whitelist: []
  shell_blacklist: ["rm -rf /", "format", "mkfs"]
  auto_backup_before_modify: false

# 功能开关
features:
  file_manager: true
  system_control: true
  browser_automation: false
  knowledge_base: false

# 存储设置
storage:
  max_conversation_history: 100
  auto_cleanup_days: 30
  backup_enabled: false
```

**需要确认的问题**：
1. 配置文件格式？（推荐YAML）
2. 配置项的详细程度？
3. 是否提供图形化设置界面？
4. 配置热更新还是重启生效？

---

### 6.2 隐私与数据安全 【待讨论】【非阻塞】

**议题6.2.1: 数据隐私策略**

**数据流向确认**：

| 数据类型 | 本地存储 | 云端上传 | 说明 |
|---------|---------|---------|------|
| 对话历史 | ✅ | ❌ | 不上传 |
| 配置文件 | ✅ | ❌ | 不上传 |
| API Key | ✅(加密) | ❌ | 不上传 |
| 知识库文档 | ✅ | ❌ | 不上传 |
| 使用统计 | 可选 | 可选 | 需用户同意 |
| 错误报告 | 可选 | 可选 | 需用户同意 |

**需要确认的问题**：
1. 是否有任何数据需要上传云端？
2. 是否提供可选的云端同步功能？（跨设备使用）
3. 匿名使用统计是否收集？

**建议决策**：
> 默认 **纯本地**，可选 **云端同步**（Phase 2）：
> - MVP阶段所有数据本地存储
> - 未来可选iCloud/OneDrive同步配置
> - 明确告知用户数据不上传

---

## 7. 开发策略议题

### 7.1 开发阶段规划 【待讨论】【非阻塞】

**议题7.1.1: 开发时间表确认**

**Phase 1: MVP核心（4-6周）**

| 周次 | 任务 | 交付物 |
|------|------|--------|
| W1 | 架构搭建 | 基础框架可运行 |
| W2 | 核心工具 | 文件操作+系统控制 |
| W3 | UI界面 | 基础聊天窗口 |
| W4 | AI接入 | 可对话执行任务 |
| W5 | 集成测试 | 端到端流程跑通 |
| W6 | 打磨优化 | Bug修复+性能优化 |

**Phase 2: 功能增强（4-6周）**
- 更多工具（浏览器、键鼠模拟）
- 知识库功能
- 体验优化（快捷键、托盘）

**Phase 3: 生态完善（4周）**
- 插件系统
- 多模型支持
- 可选云端同步

**需要确认的问题**：
1. 这个时间表现实吗？
2. 你期望的MVP发布时间？
3. 是否需要分阶段交付演示？

---

### 7.2 开源/商业策略 【待讨论】【非阻塞】

**议题7.2.1: 产品定位**

**可选模式**：

**A. 完全开源**
- 代码GitHub公开
- 自由使用修改
- 社区驱动发展

**B. 开源核心+闭源增值**
- 基础功能开源
- 高级功能付费（如云端同步）

**C. 闭源免费**
- 代码不公开
- 个人免费使用
- 公司/商业用途需授权

**D. 闭源付费**
- 软件收费销售
- 提供技术支持

**需要确认的问题**：
1. 期望的产品模式？
2. 是否有商业化计划？
3. 是否接受社区贡献代码？

**建议决策**：
> 建议 **B模式（开源核心+闭源增值）** 或 **A模式（完全开源）**：
> - 建立社区影响力
> - 基础功能满足大部分用户
> - 高级功能创造收入

---

## 8. 待确认事项清单

### 8.1 阻塞开发事项（必须确认）

| 序号 | 议题 | 章节 | 状态 |
|------|------|------|------|
| 1 | 目标用户定义 | 2.1 | 【待讨论】|
| 2 | 核心使用场景 | 2.2 | 【待讨论】|
| 3 | 桌面技术栈选择 | 3.1 | 【待讨论】|
| 4 | Python后端部署方式 | 3.2 | 【待讨论】|
| 5 | AI模型接入策略 | 3.3 | 【待讨论】|
| 6 | 混合架构执行策略 | 4.1 | 【待讨论】|
| 7 | MVP工具清单 | 4.2 | 【待讨论】|
| 8 | 主界面形式 | 5.1 | 【待讨论】|
| 9 | 数据存储策略 | 6.1 | 【待讨论】|

### 8.2 非阻塞事项（可边做边定）

| 序号 | 议题 | 章节 | 状态 |
|------|------|------|------|
| 1 | 软件集成需求 | 2.3 | 【待讨论】|
| 2 | 错误处理与恢复 | 5.2 | 【待讨论】|
| 3 | 隐私与数据安全 | 6.2 | 【待讨论】|
| 4 | 开发阶段规划 | 7.1 | 【待讨论】|
| 5 | 开源/商业策略 | 7.2 | 【待讨论】|

---

## 9. 沟通记录

### 9.1 会议记录模板

```
【日期】: YYYY-MM-DD HH:MM
【议题】: 
【参与人员】: 
【讨论内容】:
- 
【决策结果】:
- 
【行动项】:
- [ ] 任务1 - 负责人 - 截止时间
【版本更新】:
- 本文档版本: vX.X
- 更新内容: 
```

### 9.2 决策变更记录

| 版本 | 日期 | 变更议题 | 原决策 | 新决策 | 变更原因 |
|------|------|---------|--------|--------|---------|
| | | | | | |

---

## 10. 附录

### 10.1 术语表

| 术语 | 说明 |
|------|------|
| **MVP** | Minimum Viable Product，最小可行产品 |
| **ReAct** | Reasoning + Acting，推理行动循环架构 |
| **Planner** | 规划器，生成执行计划 |
| **Executor** | 执行器，执行具体步骤 |
| **Refiner** | 优化器，处理失败和异常 |
| **Tauri** | 基于Rust的桌面应用框架 |
| **IPC** | Inter-Process Communication，进程间通信 |

### 10.2 参考资料

- `OmniAgentAst_桌面版设计方案.md` - 技术设计方案
- `AI_OS_Agent_技术深度分析报告.md` - 原版技术分析
- `AI_OS_Agent_代码解析说明文档.md` - 原版代码详解

---

**更新时间**: 2026-02-15 11:44:16

*本文档记录了 OmniAgentAst. 桌面版项目的所有需求沟通议题，请在开发前确认所有阻塞项。*