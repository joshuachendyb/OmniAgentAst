# 代码自查审查经验规范

**文档版本**: v1.1  
**创建时间**: 2026-02-16 23:20:00  
**更新时间**: 2026-02-16 23:45:00  
**更新内容**: 新增"多层次审查方法"章节，补充两种审查方法对比图示  
**文档性质**: 经验总结、方法论、自查清单  
**适用范围**: 所有代码审查场景，与具体项目无关

---

## 一、文档目的

本规范基于实际代码审查经验，总结出系统性的代码自查方法。通过结构化的审查维度和检查点，帮助开发者在代码提交前发现潜在问题，提高代码质量。

**核心原则**:
- 不从表面看问题，深入逻辑和上下文
- 不仅看"有没有"，还要看"对不对"
- 考虑边界、异常、并发等多种场景
- 关注状态管理和生命周期

---

## 二、审查方法论

### 2.1 审查的三个层次

```
┌─────────────────────────────────────────────┐
│  第一层：语法和风格层面（Surface Level）      │
│  - 类型注解是否正确                          │
│  - 命名是否规范                              │
│  - 代码格式是否符合规范                      │
├─────────────────────────────────────────────┤
│  第二层：逻辑和功能层面（Logic Level）        │
│  - 代码逻辑是否正确                          │
│  - 分支是否完整                              │
│  - 算法是否正确                              │
├─────────────────────────────────────────────┤
│  第三层：架构和设计层面（Architecture Level） │
│  - 状态管理是否合理                          │
│  - 生命周期是否正确                          │
│  - 并发安全性                                │
│  - 异常处理策略                              │
└─────────────────────────────────────────────┘
```

### 2.2 审查的核心思维方式

#### 思维方式1：攻击者视角
- 不假设输入总是正确的
- 考虑"如果...会怎样"
- 主动寻找代码的薄弱点

#### 思维方式2：状态机思维
- 识别代码中的所有状态
- 追踪状态如何变化和流转
- 检查状态转换是否完整

#### 思维方式3：边界探索
- 最小输入（空值、0、None）
- 最大输入（极限值、超大集合）
- 异常输入（类型错误、格式错误）

#### 思维方式4：并发意识
- 多线程/协程同时执行会怎样
- 共享状态是否安全
- 竞态条件是否存在

---

## 三、多层次审查方法（核心方法论）

### 3.1 三层审查架构

基于实际项目经验，代码审查应该分为三个层次，逐层深入。每一层关注不同的质量问题，使用不同的审查方法。

```
┌─────────────────────────────────────────────────────────────┐
│                    代码审查三层架构                           │
├─────────────────────────────────────────────────────────────┤
│  第一层：功能正确性审查（Functional Review）                   │
│  ├─ 目标：验证代码是否实现了预期功能                          │
│  ├─ 方法：静态代码阅读 + 测试验证                            │
│  ├─ 关注点：逻辑正确性、接口契约、返回值                      │
│  └─ 产出：功能缺陷列表                                        │
├─────────────────────────────────────────────────────────────┤
│  第二层：深度质量审查（Quality Review）                        │
│  ├─ 目标：发现边界条件、异常场景下的问题                      │
│  ├─ 方法：动态执行模拟 + 边界探索 + 状态追踪                  │
│  ├─ 关注点：输入验证、状态管理、并发安全、异常处理            │
│  └─ 产出：质量缺陷列表                                        │
├─────────────────────────────────────────────────────────────┤
│  第三层：安全与性能审查（Security & Performance Review）       │
│  ├─ 目标：发现安全漏洞和性能瓶颈                              │
│  ├─ 方法：攻击者视角 + 压力测试 + 工具扫描                    │
│  ├─ 关注点：注入风险、敏感数据、资源泄漏、算法复杂度          │
│  └─ 产出：安全和性能优化建议                                  │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 第一层：功能正确性审查

#### 3.2.1 审查目标
验证代码是否**正确地实现了需求规格说明**中的功能，是最基础的审查层次。

#### 3.2.2 审查方法

**方法1：契约检查法**
```python
# 检查函数契约是否被遵守
def send_message(user_id: str, content: str) -> Message:
    # 检查1: 参数类型是否符合注解？
    # 检查2: 返回值类型是否符合注解？
    # 检查3: 异常情况返回什么？
```

**方法2：测试验证法**
- 运行单元测试，验证所有测试通过
- 检查测试用例是否覆盖了主要功能路径
- 验证边界值测试是否正确

**方法3：文档核对法**
- 对照设计文档检查实现是否一致
- 验证接口定义是否准确
- 确认命名是否符合约定

#### 3.2.3 检查清单

**功能正确性检查清单**:
- [ ] 函数是否实现了预期的功能？
- [ ] 返回值类型是否与类型注解一致？
- [ ] 所有分支是否都有正确的返回值？
- [ ] 接口契约是否被正确遵守？
- [ ] 命名是否符合命名规范？
- [ ] 文档字符串是否准确描述了功能？

**典型问题示例**:
```python
# 问题1: 别名指向错误（功能层面问题）
dict_history_to_messages = messages_to_dict_list  
# 语义是 dict→message，但指向的是 message→dict

# 问题2: 返回类型与注解不符
def find_user(user_id) -> User:
    if not user_exists(user_id):
        return None  # 违反类型注解！应该是 Optional[User]

# 问题3: 文档与实现不符
# 文档说: "返回用户列表，最多10条"
# 实际: 返回所有匹配用户，无限制
```

#### 3.2.4 工具支持

- **类型检查**: mypy, pyright
- **代码规范**: pylint, flake8
- **文档检查**: pydocstyle
- **测试覆盖**: pytest-cov

### 3.3 第二层：深度质量审查

#### 3.3.1 审查目标
发现代码在**边界条件、异常场景、并发环境**下的潜在问题。这一层需要更深入的思考和模拟。

#### 3.3.2 审查方法

**方法1：边界探索法**
```python
# 对每一个输入参数，考虑以下情况：
def process_list(items: List[Item]):
    # 情况1: items = None（空指针）
    # 情况2: items = []（空列表）
    # 情况3: items = [None]（包含None元素）
    # 情况4: items 包含100万个元素（超大集合）
    for item in items:
        ...
```

**方法2：状态追踪法**
```python
# 追踪对象状态随时间的变化
class Agent:
    def __init__(self):
        self.steps = []  # t0: 空列表
    
    async def run(self, task):
        # t1: 第一次调用，steps=[]
        # t2: 执行中，steps=[step1, step2]
        # t3: 返回后，steps=[step1, step2]
        # t4: 第二次调用，steps还是=[step1, step2]！
        self.steps.append(...)  # 状态累积污染！
```

**方法3：并发模拟法**
```python
# 模拟多个执行流同时进行
async def test_concurrent():
    agent = Agent()
    # 启动3个协程同时调用
    tasks = [
        agent.run("任务1"),  # 协程A
        agent.run("任务2"),  # 协程B
        agent.run("任务3"),  # 协程C
    ]
    # 检查是否有竞态条件、状态混乱
```

**方法4：异常注入法**
```python
# 模拟每一步可能失败的情况
def process():
    try:
        data = load_data()    # 如果这里失败？
        result = process(data)  # 如果这里失败？
        save(result)           # 如果这里失败？
    except Exception as e:
        # 异常后系统状态是否一致？
        # 资源是否正确释放？
        pass
```

#### 3.3.3 检查清单

**输入验证检查**:
- [ ] 所有参数是否都进行了空值检查？
- [ ] 集合参数是否处理了空集合？
- [ ] 字典访问是否使用了安全的`.get()`？
- [ ] 类型转换是否有异常处理？

**状态管理检查**:
- [ ] 方法多次调用是否安全？
- [ ] 状态是否在调用间正确隔离？
- [ ] 是否有状态累积污染？
- [ ] 资源是否正确释放？

**并发安全检查**:
- [ ] 代码是否可能在多线程/协程环境使用？
- [ ] 共享状态操作是否原子？
- [ ] 是否有竞态条件？
- [ ] 是否需要锁保护？

**异常处理检查**:
- [ ] 所有可能的异常都被捕获了吗？
- [ ] 异常后状态是否一致？
- [ ] 资源在异常情况下是否释放？
- [ ] 是否吞掉了不该吞的异常？

#### 3.3.4 典型问题示例

```python
# 问题1: 空值检查缺失
def convert_messages(messages):
    return [{"role": m.role, "content": m.content} for m in messages]
    # 如果 messages = None 或 messages = [None] 会崩溃

# 问题2: 状态污染
class Processor:
    def __init__(self):
        self.results = []
    
    def process(self, data):
        self.results.append(data)  # 多次调用会累积结果
        return self.results

# 问题3: 并发竞态
class Counter:
    def increment(self):
        current = self.count
        self.count = current + 1  # 非原子操作，并发不安全

# 问题4: 异常后资源泄漏
def process_file(filename):
    f = open(filename)
    data = f.read()
    # 如果这里抛出异常，f不会关闭
    f.close()
```

### 3.4 第三层：安全与性能审查

#### 3.4.1 审查目标
发现**安全漏洞**（注入、越权、数据泄露）和**性能问题**（算法复杂度、资源泄漏、热点代码）。

#### 3.4.2 审查方法

**方法1：攻击者视角**
```python
# 思考：如果我是攻击者，会如何攻击这段代码？
def query_user(user_input):
    # 攻击1: SQL注入
    sql = f"SELECT * FROM users WHERE name = '{user_input}'"
    # 攻击2: 命令注入
    os.system(f"grep {user_input} log.txt")
    # 攻击3: 路径遍历
    open(f"/data/{user_input}")
```

**方法2：复杂度分析**
```python
# 分析时间和空间复杂度
def find_duplicates(items):
    result = []
    for i in range(len(items)):          # O(n)
        for j in range(i+1, len(items)): # O(n)
            if items[i] == items[j]:     # O(1)
                result.append(items[i])  # 可能是O(n)扩容
    return result
    # 总复杂度: O(n²)，当n=10000时会非常慢
```

**方法3：资源审计**
```python
# 追踪所有资源的生命周期
class Service:
    def __init__(self):
        self.connections = []  # 连接池
    
    def handle_request(self):
        conn = create_connection()  # 创建资源
        self.connections.append(conn)
        # 连接是否有上限？是否会被关闭？
```

#### 3.4.3 检查清单

**安全检查**:
- [ ] 是否有SQL注入风险？（使用参数化查询）
- [ ] 是否有命令注入风险？（避免shell=True）
- [ ] 是否有路径遍历风险？（验证路径）
- [ ] 敏感数据是否被正确保护？
- [ ] 用户输入是否被转义？

**性能检查**:
- [ ] 算法复杂度是否合理？（避免O(n²)以上）
- [ ] 是否有N+1查询问题？
- [ ] 是否有内存泄漏？（循环引用、未释放资源）
- [ ] 热点代码是否可以缓存？
- [ ] I/O操作是否可以异步化？

#### 3.4.4 工具支持

- **安全扫描**: bandit, safety, semgrep
- **性能分析**: cProfile, line_profiler, memory_profiler
- **复杂度检查**: radon, xenon
- **依赖检查**: pip-audit, safety check

### 3.5 三层审查的执行流程

#### 3.5.1 时间分配建议

| 层次 | 时间占比 | 关注点 | 产出 |
|------|---------|--------|------|
| 第一层 | 30% | 功能正确性 | 功能缺陷 |
| 第二层 | 50% | 质量和鲁棒性 | 质量缺陷 |
| 第三层 | 20% | 安全和性能 | 优化建议 |

#### 3.5.2 逐层过滤策略

```
第一轮：功能正确性审查（必做）
    ├─ 发现问题 → 记录并修复
    └─ 通过 → 进入第二轮

第二轮：深度质量审查（必做）
    ├─ 发现问题 → 记录并修复
    └─ 通过 → 进入第三轮

第三轮：安全性能审查（选择性）
    ├─ 涉及安全/性能的关键代码 → 详细审查
    └─ 普通业务代码 → 快速检查
```

#### 3.5.3 不同场景的应用

**场景1：新功能开发**
- 三层审查都要执行
- 重点关注第二层的边界条件

**场景2：Bug修复**
- 重点执行第一层（验证修复正确）
- 第二层（检查是否有类似问题）

**场景3：重构优化**
- 重点执行第一层（保持功能不变）
- 第三层（验证性能提升）

**场景4：紧急补丁**
- 至少执行第一层
- 后续补充第二、三层审查

### 3.6 三层审查的对比总结

| 维度 | 第一层 | 第二层 | 第三层 |
|------|--------|--------|--------|
| **目标** | 功能正确 | 质量可靠 | 安全高效 |
| **方法** | 静态阅读 | 动态模拟 | 攻击者视角 |
| **关注点** | 逻辑正确性 | 边界和异常 | 安全和性能 |
| **发现率** | 60% | 30% | 10% |
| **修复成本** | 低 | 中 | 高 |
| **审查者** | 任何开发者 | 资深开发者 | 专家/安全团队 |

### 3.7 两种审查方法的互补关系

在实际项目中，通常会有来自不同视角的审查报告。理解这些审查方法的关系，有助于综合评估代码质量。

```
┌─────────────────────────────────────────┐
│         完整的代码审查应该包含：          │
├─────────────────────────────────────────┤
│ 第一层：功能正确性审查（如独立审核报告）   │
│ - 验证功能是否正确实现                   │
│ - 检查明显的逻辑错误                     │
│ - 核对文档和测试                         │
│ - 产出：功能缺陷列表（如别名指向错误）     │
├─────────────────────────────────────────┤
│ 第二层：深度质量审查（如漏洞分析报告）     │
│ - 防御性编程检查（空值、边界、异常）       │
│ - 状态管理和生命周期分析                  │
│ - 并发安全性检查                         │
│ - 产出：质量缺陷列表（如状态污染、竞态条件）│
├─────────────────────────────────────────┤
│ 第三层：安全与性能审查                    │
│ - 注入风险和敏感数据检查                   │
│ - 算法复杂度和资源泄漏分析                 │
│ - 产出：安全和性能优化建议                 │
└─────────────────────────────────────────┘
```

**为什么需要多种审查方法？**

从Wave 1的实际案例可以看出：

| 审查方法 | 发现问题数 | 典型发现 | 局限性 |
|---------|-----------|---------|--------|
| **功能审查** | 3个 | 别名指向错误 | 未发现状态管理和并发问题 |
| **深度审查** | 8个 | 状态污染、竞态条件 | 可能遗漏简单功能错误 |
| **综合应用** | 11个 | 全覆盖 | 需要更多时间和经验 |

**结论**：不同层次的审查方法相互补充，单一方法无法覆盖所有问题类型。建议结合使用多种审查方法。

### 3.8 实践案例：从Wave 1审查看三层方法的应用

**案例背景**: Wave 1修改修复了3个问题，但审查发现的质量问题差异巨大。

**第一层审查结果（功能正确性）**:
```
✅ 问题#3修复: adapter.py正确实现了参数转换
✅ 问题#6修复: Session管理功能正确
✅ 问题#8修复: 数据库连接关闭功能正确

🔴 发现新问题: adapter.py第110行别名指向错误
   - 语义与实际指向相反
   - 属于功能缺陷
```

**第二层审查结果（深度质量）**:
```
🔴 adapter.py - 缺少空值检查
🔴 agent.py - 多次调用会导致状态污染
🔴 agent.py - 并发调用存在竞态条件
🔴 agent.py - Session生命周期管理有漏洞
🟡 agent.py - LLM客户端参数类型不匹配
🟡 agent.py - 异常处理过于宽泛

📊 第二层发现的问题数量是第一层的2倍
```

**第三层审查结果（安全性能）**:
```
🟢 当前代码没有明显的安全漏洞
🟡 需要关注大规模数据下的性能
🟡 数据库连接池可能需要优化
```

**启示**:
- 仅做第一层审查会遗漏50%以上的质量问题
- 第二层审查是发现问题的关键（贡献70%的问题发现）
- 第三层审查针对性强，但不可或缺

---

## 四、审查维度与检查点

### 维度1：输入验证与防御性编程

**审查问题清单**:
- [ ] 函数参数是否进行了空值检查？
- [ ] 集合类型参数（List, Dict）是否检查了空集合？
- [ ] 字符串参数是否检查了空字符串和仅空白字符？
- [ ] 数值参数是否检查了负数、零、极大值？
- [ ] 对象参数是否验证了必需的属性存在？
- [ ] 字典访问是否使用了安全的`.get()`方法而非`[]`？
- [ ] 类型转换是否有异常处理？

**典型漏洞模式**:
```python
# 危险模式1: 直接遍历，未检查None
def process_list(items):
    for item in items:  # 如果items为None会崩溃
        ...

# 危险模式2: 直接访问字典键
def get_config(config):
    value = config["key"]  # 如果键不存在会崩溃
    ...

# 危险模式3: 假设属性存在
def process_message(msg):
    role = msg.role  # 如果msg没有role属性会崩溃
    ...
```

**安全模式**:
```python
# 安全模式1: 防御性检查
def process_list(items):
    if items is None:
        return []
    for item in items or []:
        ...

# 安全模式2: 安全访问
def get_config(config):
    value = config.get("key", default_value)
    ...

# 安全模式3: 属性检查
def process_message(msg):
    if not hasattr(msg, 'role'):
        return
    role = msg.role
    ...
```

---

### 维度2：状态管理与生命周期

**审查问题清单**:
- [ ] 类是否有实例级别的状态？
- [ ] 状态是否在多次调用间正确隔离？
- [ ] 资源（连接、文件、锁）是否正确释放？
- [ ] 是否有try-finally或上下文管理器保证资源释放？
- [ ] 对象的创建和销毁是否配对？
- [ ] 引用计数是否正确管理？

**典型漏洞模式**:
```python
# 危险模式1: 状态累积污染
class Processor:
    def __init__(self):
        self.results = []
    
    def process(self, data):
        self.results.append(data)  # 多次调用会累积
        return self.results

# 危险模式2: 资源泄漏
class DatabaseClient:
    def query(self, sql):
        conn = create_connection()
        result = conn.execute(sql)
        return result  # 连接未关闭！

# 危险模式3: 异常情况下资源未释放
def process_file(filename):
    f = open(filename, 'r')
    data = f.read()
    # 如果这里抛出异常，文件不会关闭
    f.close()
```

**安全模式**:
```python
# 安全模式1: 每次调用重置状态
class Processor:
    def process(self, data):
        results = []  # 局部状态
        results.append(data)
        return results

# 安全模式2: 上下文管理器
class DatabaseClient:
    def query(self, sql):
        with create_connection() as conn:
            return conn.execute(sql)

# 安全模式3: try-finally保证释放
def process_file(filename):
    f = open(filename, 'r')
    try:
        return f.read()
    finally:
        f.close()
```

---

### 维度3：并发安全性

**审查问题清单**:
- [ ] 代码是否可能在多线程/协程环境中使用？
- [ ] 是否有共享的可变状态？
- [ ] 对共享状态的操作是否是原子的？
- [ ] 是否有竞态条件？
- [ ] 是否有死锁风险？
- [ ] 并发调用是否会导致状态混乱？

**典型漏洞模式**:
```python
# 危险模式1: 竞态条件
class Counter:
    def __init__(self):
        self.count = 0
    
    def increment(self):
        current = self.count
        self.count = current + 1  # 非原子操作，并发时会丢失更新

# 危险模式2: 多次调用同一实例
class TaskRunner:
    async def run(self, task):
        self.status = "running"  # 并发调用会覆盖状态
        await process(task)
        self.status = "completed"
```

**安全模式**:
```python
# 安全模式1: 锁保护
import asyncio

class Counter:
    def __init__(self):
        self.count = 0
        self.lock = asyncio.Lock()
    
    async def increment(self):
        async with self.lock:
            self.count += 1

# 安全模式2: 状态隔离
class TaskRunner:
    async def run(self, task):
        local_status = "running"  # 使用局部状态
        await process(task)
        return local_status
```

---

### 维度4：异常处理策略

**审查问题清单**:
- [ ] 所有可能的异常都被捕获了吗？
- [ ] 捕获异常后是否进行了适当的处理？
- [ ] 异常信息是否被记录？
- [ ] 是否吞掉了不应该吞的异常？
- [ ] 异常发生后系统状态是否一致？
- [ ] 是否有清理逻辑在finally中执行？

**典型漏洞模式**:
```python
# 危险模式1: 空catch块
def process():
    try:
        risky_operation()
    except:  # 捕获所有异常但什么都不做
        pass  # 异常被吞掉，问题被隐藏

# 危险模式2: 在catch中继续执行
def process():
    try:
        data = load_data()
    except Exception:
        data = None  # 设为None继续
    process_data(data)  # 可能导致后续错误

# 危险模式3: 异常后状态不一致
def transfer(from_acc, to_acc, amount):
    from_acc.balance -= amount  # 扣款
    # 如果这里抛出异常，钱就没了！
    to_acc.balance += amount
```

**安全模式**:
```python
# 安全模式1: 具体异常处理
def process():
    try:
        risky_operation()
    except ValueError as e:
        logger.error(f"Invalid value: {e}")
        raise  # 重新抛出或返回错误
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        raise

# 安全模式2: 事务性操作
def transfer(from_acc, to_acc, amount):
    try:
        from_acc.balance -= amount
        to_acc.balance += amount
        # 原子性提交
        commit()
    except Exception:
        rollback()  # 回滚
        raise
```

---

### 维度5：类型安全与接口契约

**审查问题清单**:
- [ ] 类型注解是否准确？
- [ ] 函数返回值类型是否一致？
- [ ] 接口契约是否被遵守？
- [ ] 类型转换是否安全？
- [ ] Optional类型是否都处理了None？
- [ ] 泛型使用是否正确？

**典型漏洞模式**:
```python
# 危险模式1: 返回类型不一致
def find_user(user_id) -> User:
    if user_exists(user_id):
        return get_user(user_id)
    return None  # 违反类型注解，应该返回Optional[User]

# 危险模式2: 隐式类型转换
def calculate(a, b):
    return a + b  # 如果a是字符串，b是数字会崩溃

# 危险模式3: 接口契约破坏
class Client:
    def send(self, message: str) -> Response:
        # 实际返回了Dict而不是Response
        return {"status": "ok"}
```

---

### 维度6：上下文与依赖关系

**审查问题清单**:
- [ ] 代码依赖了哪些外部状态？
- [ ] 这些依赖是否被正确初始化？
- [ ] 调用顺序是否有要求？
- [ ] 是否有循环依赖？
- [ ] 依赖的版本兼容性如何？
- [ ] 环境变化是否会影响代码？

**分析方法**:
1. 画出依赖图，标记所有外部依赖
2. 检查每个依赖的初始化时机
3. 验证调用顺序约束
4. 模拟依赖缺失或异常的情况

---

## 四、问题发现的方法论

### 4.1 从显性代码到隐性逻辑

**方法：追问五个为什么**

当看到一个变量赋值时：
1. 这个变量从哪里来？（输入参数？外部状态？）
2. 它可能是什么值？（正常值？边界值？异常值？）
3. 如果它是None/空值/异常值会怎样？
4. 后续代码如何处理这些值？
5. 是否有遗漏的处理分支？

**示例**：
```python
# 代码片段
user = get_user(user_id)
email = user.email
```

**追问过程**：
1. `get_user`从哪里获取用户？数据库？缓存？
2. 如果`user_id`不存在会怎样？返回None？抛出异常？
3. 如果`user`为None，访问`user.email`会崩溃
4. 是否有检查`if user is not None`？
5. 如果没有，这就是一个漏洞

### 4.2 从静态代码到动态执行

**方法： mentally trace execution**

在脑中模拟代码执行，考虑不同路径：

1. **正常路径**：输入符合预期，代码如何执行？
2. **边界路径**：输入在边界值，代码如何执行？
3. **异常路径**：中间步骤失败，代码如何执行？
4. **并发路径**：多个执行流同时进行，会发生什么？

**示例**：
```python
def process_items(items):
    results = []
    for item in items:
        result = process(item)
        if result:
            results.append(result)
    return results
```

**trace分析**：
- 正常：items=[1,2,3]，每个都能处理，返回3个结果
- 边界：items=[]，循环不执行，返回[] ✓
- 边界：items=None，直接崩溃 ✗
- 异常：process(item)抛出异常，整个函数崩溃 ✗
- 并发：如果items被其他线程修改，可能异常

### 4.3 从局部代码到全局影响

**方法：扩大分析范围**

不仅看当前函数，还要看：
1. 谁调用了这个函数？（调用者分析）
2. 这个函数调用了谁？（依赖分析）
3. 修改了哪些共享状态？（副作用分析）
4. 异常会如何传播？（传播分析）

### 4.4 从当前状态到时间演变

**方法：时间线分析**

追踪状态随时间的变化：

```
时间点  状态变化
─────────────────────────
t0      对象创建，初始状态
t1      方法调用，状态改变
t2      异常发生，状态不确定
t3      finally执行，清理状态
t4      对象销毁，资源释放
```

**检查点**：
- 每个时间点状态是否一致？
- 异常发生后状态是否可恢复？
- 资源是否正确释放？

---

## 五、通用审查清单（Checklist）

### 5.1 函数级别审查清单

**函数签名检查**:
- [ ] 参数类型注解是否完整？
- [ ] 返回值类型注解是否准确？
- [ ] 是否有Optional参数需要处理None？
- [ ] 参数命名是否清晰表达了含义？

**函数体检查**:
- [ ] 第一行是否进行了参数验证？
- [ ] 所有分支是否都有返回值？
- [ ] 循环是否有终止条件？
- [ ] 递归是否有终止条件？
- [ ] 资源是否在finally中释放？

**函数间检查**:
- [ ] 调用其他函数时参数是否正确？
- [ ] 返回值是否被正确处理？
- [ ] 异常是否被捕获或传播？

### 5.2 类级别审查清单

**类设计检查**:
- [ ] 类的职责是否单一？
- [ ] 实例变量是否必要？
- [ ] 可变状态是否最小化？
- [ ] 是否线程安全？

**方法检查**:
- [ ] __init__是否建立了有效状态？
- [ ] 方法是否修改了不应修改的状态？
- [ ] 方法调用顺序是否有隐含要求？
- [ ] 多次调用同一方法是否安全？

### 5.3 模块级别审查清单

**依赖检查**:
- [ ] 导入是否都在文件顶部？
- [ ] 是否有循环导入风险？
- [ ] 依赖的版本兼容性如何？
- [ ] 是否依赖了全局状态？

**接口检查**:
- [ ] 公开接口是否清晰？
- [ ] 内部实现是否被意外暴露？
- [ ] 接口契约是否稳定？

---

## 六、审查流程建议

### 6.1 提交前自查流程（10分钟）

```
第1-2分钟：快速浏览
  - 检查明显的语法错误
  - 检查命名规范
  - 检查代码格式

第3-5分钟：逻辑检查
  - 使用审查清单检查关键问题
  - 关注输入验证和异常处理
  - 检查明显的逻辑错误

第6-8分钟：深度分析
  - 选择1-2个关键函数深入分析
  - 考虑边界条件和异常情况
  - 检查状态管理

第9-10分钟：上下文检查
  - 检查与现有代码的兼容性
  - 验证接口契约
  - 考虑测试覆盖
```

### 6.2 代码审查会议流程（30分钟）

```
第1-5分钟：背景介绍
  - 修改目的和范围
  - 涉及的主要文件
  - 关键设计决策

第6-20分钟：逐行审查
  - 按照审查维度逐项检查
  - 重点关注高风险区域
  - 记录所有问题和建议

第21-25分钟：测试讨论
  - 测试用例是否充分
  - 边界情况是否覆盖
  - 是否需要补充测试

第26-30分钟：总结行动项
  - 分类问题（阻塞/建议/可选）
  - 确定修复优先级
  - 分配修复责任人
```

---

## 七、常见问题模式库

### 模式1：空值灾难链

**症状**：一连串函数调用，每个都可能返回None，但都没有检查

**检测方法**：追踪所有可能返回None的调用点

**修复策略**：在源头处理，使用Null Object模式或尽早返回

### 模式2：隐式状态依赖

**症状**：函数行为依赖于外部状态，而不是参数

**检测方法**：检查函数是否读取了非参数的外部变量

**修复策略**：将依赖转为参数，或使用依赖注入

### 模式3：异常黑洞

**症状**：捕获所有异常但什么都不做

**检测方法**：搜索空的except块或只有pass的异常处理

**修复策略**：记录日志、恢复状态、或重新抛出

### 模式4：资源泄漏

**症状**：打开的资源（文件、连接、锁）没有对应的关闭

**检测方法**：检查所有资源获取点，验证是否有对应的释放

**修复策略**：使用上下文管理器或try-finally

### 模式5：类型谎言

**症状**：类型注解承诺了类型，但实现返回了其他类型

**检测方法**：对比类型注解和实际返回值

**修复策略**：修正类型注解或实现，保持一致

---

## 八、工具和实践建议

### 8.1 推荐的静态分析工具

1. **类型检查**：mypy, pyright
2. **代码质量**：pylint, flake8, black
3. **安全扫描**：bandit, safety
4. **复杂度分析**：radon, xenon

### 8.2 代码审查最佳实践

1. **小批量提交**：每次审查的代码不超过400行
2. **自审查先行**：提交前先自己审查一遍
3. **使用检查清单**：不要凭感觉，按照清单逐项检查
4. **关注重点**：80%的精力放在20%的关键代码上
5. **建设性反馈**：指出问题的同时给出改进建议

### 8.3 团队审查文化

1. **心理安全**：审查的是代码，不是人
2. **学习机会**：把审查当作学习他人思路的机会
3. **知识共享**：通过审查传播团队知识和最佳实践
4. **持续改进**：定期回顾审查流程，不断优化

---

## 九、总结

### 9.1 核心审查原则

1. **全面性**：不只关注功能正确，还要关注可靠性、安全性、可维护性
2. **深度性**：不只停留在表面，要深入逻辑和上下文
3. **系统性**：使用结构化的方法和清单，避免遗漏
4. **前瞻性**：考虑未来可能的变化和扩展

### 9.2 快速参考卡片

```
┌────────────────────────────────────────┐
│         代码审查速查卡                  │
├────────────────────────────────────────┤
│ 输入检查：None? 空值? 类型?             │
│ 状态管理：是否隔离? 是否正确释放?        │
│ 并发安全：共享状态? 竞态条件?            │
│ 异常处理：是否捕获? 是否正确处理?        │
│ 类型安全：注解准确? 返回值一致?          │
│ 上下文：依赖关系? 调用顺序?              │
└────────────────────────────────────────┘
```

---

**文档创建时间**: 2026-02-16 23:20:00  
**基于经验**: Wave 1 代码审查实践  
**更新周期**: 建议每季度回顾更新  
**使用方式**: 打印为速查卡，放置于工位随时参考

---

## 版本记录

| 版本 | 时间 | 更新内容 | 作者 |
|------|------|---------|------|
| v1.0 | 2026-02-16 23:20:00 | 初始版本，包含6大审查维度和方法论 | AI开发助手 |
| v1.1 | 2026-02-16 23:45:00 | 新增"多层次审查方法"章节（第三章），详细描述三层审查架构；补充两种审查方法对比图示；新增实践案例（Wave 1审查分析） | AI开发助手 |
