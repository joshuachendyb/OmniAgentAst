# OmniAgentAst. 开发策略规范

**文档编号**: OMA-DEV-001  
**版本**: v2.0  
**创建时间**: 2026-02-15 22:05:53  
**更新时间**: 2026-02-15 22:30:00  
**适用范围**: OmniAgentAst. 桌面版项目全生命周期  
**制定原则**: 质量优先，稳扎稳打，杜绝"快但烂"

---

## 文档结构说明

本文档分为两大部分：

**第一部分（第1-9章）：核心基础规范**
- 通用开发原则和方法论
- 渐进式开发策略的核心框架
- 适用于所有软件开发项目的基础规范
- 经验来源：《软件代码迭代规范》《代码检查方法》《代码风险分析方法》等

**第二部分（第10-17章）：OmniAgent项目具体实施**
- 基于第一部分规范制定的项目实施方案
- OmniAgentAst.桌面版特有的技术选型和架构设计
- 项目各阶段的具体开发计划和验收标准
- 经验来源：《开发优先级计划》《OmniAgentAst_桌面版设计方案》

---

# 第一部分：核心基础规范

---

## 1. 核心理念

### 1.1 开发铁律（必须遵守）

| 优先级 | 铁律 | 违反后果 | 经验来源 |
|--------|------|---------|---------|
| **P0** | **质量 > 速度** | 宁可慢，不可用 | 《软件代码迭代规范》 |
| **P0** | **测试先行** | 无测试 = 未完成 | 《软件代码迭代规范》 |
| **P0** | **阶段锁定** | 前一阶段未验收，绝不开始下一阶段 | 《软件代码迭代规范》 |
| **P0** | **先分析，再动手** | 设计文档批准后才能编码 | 《软件代码迭代规范》 |
| **P1** | **闭环整改** | 发现问题必须修复验证 | 《代码检查方法》 |
| **P1** | **用户验收** | 每个阶段必须用户确认可用 | 实践经验 |
| **P2** | **渐进累加** | 每个阶段输出是可验证的增量 | 《软件代码迭代规范》 |

### 1.2 失败案例警示

> **反面教材**: "AI七里哐啷开发完成，结果啥都不能用"
> 
> **根本原因**:
> 1. 追求速度，忽视质量（违反"质量>速度"）
> 2. 缺少测试，问题累积（违反"测试先行"）
> 3. 阶段跳跃，基础不牢（违反"阶段锁定"）
> 4. 没有Review，代码失控（违反"闭环整改"）
> 5. 先编码后补文档（违反"先分析再动手"）
> 
> **本规范目标**: 杜绝此类情况再次发生

### 1.3 渐进式开发策略

**核心思想**：不求快，只求稳，分阶段推进，每个阶段都是可验证的增量。

```
阶段1（基础）→ 阶段2（核心）→ 阶段3（增强）→ 阶段4（完善）
     ↓              ↓              ↓              ↓
  可运行的       可用的         好用的         完善的
  骨架          功能           体验           产品
```

**策略要点**：
- ✅ 每个阶段有明确目标和验收标准
- ✅ 前一阶段验收通过才能进入下一阶段
- ✅ 阶段内发现问题必须闭环整改
- ✅ 每个阶段输出是可独立验证的增量

---

## 2. 阶段开发流程（标准SOP）

### 2.1 阶段生命周期（9步流程，缺一不可）

```
┌─────────────────────────────────────────────────────────────┐
│                    阶段 N 开发流程                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. 阶段启动                                                 │
│     ├─ 确认前一阶段已锁定（Git标签已打）                      │
│     ├─ 创建阶段分支（phase/阶段号）                          │
│     └─ 确认工作区干净（无未提交修改）                         │
│                        ↓                                    │
│  2. 设计文档编写 （必须先分析！）                             │
│     ├─ 阶段目标描述                                          │
│     ├─ 技术方案设计                                          │
│     ├─ 验收标准清单（可验证的！）                             │
│     └─ 用户批准后才能进入下一步                               │
│                        ↓                                    │
│  3. 功能开发（边开发边测试）                                  │
│     ├─ 编写功能代码                                          │
│     ├─ 同步编写单元测试（测试先行）                           │
│     └─ 代码规范检查（ESLint/Pylint通过）                      │
│                        ↓                                    │
│  4. 测试验证                                                │
│     ├─ 运行单元测试（100%通过）                               │
│     ├─ 边界情况测试（null、空值、极值）                       │
│     └─ 生成测试报告（覆盖率≥80%）                            │
│                        ↓                                    │
│  5. 代码审查（闭环整改！）                                    │
│     ├─ 逻辑正确性检查（功能是否符合设计）                     │
│     ├─ 代码质量检查（命名、注释、结构）                       │
│     ├─ 风险分析（边界、异常、安全）                          │
│     ├─ 发现问题 → 修复 → 验证（闭环）                        │
│     └─ 生成审查记录                                          │
│                        ↓                                    │
│  6. 阶段总结                                                │
│     ├─ 完成功能清单                                          │
│     ├─ 问题与解决方案                                        │
│     └─ 待改进项                                              │
│                        ↓                                    │
│  7. 用户验收（最关键！）                                      │
│     ├─ 演示阶段成果                                          │
│     ├─ 用户实际使用测试                                      │
│     └─ 确认验收或打回修改                                    │
│                        ↓                                    │
│  8. 阶段锁定（版本号管理）                                    │
│     ├─ 按语义化版本打Git标签（v0.X.0-phaseN）                 │
│     ├─ 归档阶段文档                                          │
│     └─ 禁止修改（如需修改走补丁流程）                         │
│                        ↓                                    │
│  9. 进入下一阶段                                            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 关键检查点（不能跳过）

| 检查点 | 检查内容 | 不通过后果 |
|--------|---------|-----------|
| **设计批准** | 设计文档用户批准 | 不能开始编码 |
| **测试通过** | 单元测试100%通过 | 不能进入审查 |
| **闭环整改** | 审查问题全部修复 | 不能进入总结 |
| **用户验收** | 用户确认可用 | 不能锁定阶段 |

### 2.3 阶段状态定义

| 状态 | 定义 | 转换条件 |
|------|------|---------|
| **待启动** | 阶段尚未开始 | 前一阶段已锁定 |
| **进行中** | 正在进行开发 | 设计文档已批准 |
| **待测试** | 功能开发完成 | 代码已提交 |
| **测试中** | 正在进行测试 | 测试用例已编写 |
| **待审查** | 测试已通过 | 测试报告已生成 |
| **审查中** | 正在进行代码审查 | 代码审查发起 |
| **待验收** | 审查已通过 | 问题已修复 |
| **验收中** | 用户正在验收 | 阶段总结已完成 |
| **已锁定** | 阶段已完成并锁定 | 用户确认验收 |
| **已打回** | 验收未通过需修改 | 用户提出修改意见 |

---

## 3. 文档规范（3个必须文档）

每个阶段必须产出以下3个文档，缺一不可：

### 3.1 阶段设计文档（编码前）

**文件名**: `阶段X-设计文档-YYYY-MM-DD.md`

**必须包含**:
```markdown
# 阶段X：阶段名称 - 设计文档

## 1. 阶段目标
- 要实现什么功能
- 解决什么问题
- 预期效果

## 2. 技术方案
- 架构设计
- 关键技术选型
- 接口定义
- 数据结构设计

## 3. 验收标准（必须可验证！）
- [ ] 验收项1：具体描述 + 验证方法
- [ ] 验收项2：具体描述 + 验证方法
- [ ] 验收项3：具体描述 + 验证方法

## 4. 风险预估
- 可能遇到的问题
- 应对方案

## 5. 参考资料
- 相关文档链接
```

### 3.2 测试报告（测试后）

**文件名**: `阶段X-测试报告-YYYY-MM-DD.md`

**必须包含**:
```markdown
# 阶段X：阶段名称 - 测试报告

## 1. 测试概述
- 测试时间
- 测试环境
- 测试人员

## 2. 测试统计
- 总用例数：X
- 通过率：Y/X (100%才能通过)
- 覆盖率：XX% (≥80%)

## 3. 测试用例清单
| 用例ID | 描述 | 类型 | 状态 |
|--------|------|------|------|
| TC001 | ... | 单元测试 | ✅通过 |
| TC002 | ... | 边界测试 | ❌失败 |

## 4. 问题清单
- 发现的问题及修复状态

## 5. 测试结论
- 是否通过阶段测试
- 遗留问题
```

### 3.3 阶段总结（验收前）

**文件名**: `阶段X-阶段总结-YYYY-MM-DD.md`

**必须包含**:
```markdown
# 阶段X：阶段名称 - 阶段总结

## 1. 完成情况
- 计划：X项 / 完成：Y项 / 未完成：Z项

## 2. 技术实现
- 关键代码说明
- 架构图
- 技术难点及解决方案

## 3. 问题记录
- 遇到的问题及解决方法
- 经验教训

## 4. 待改进项
- 已知缺陷和优化建议
- 后续阶段需要注意的问题

## 5. 阶段资产
- 代码变更清单
- 新增/修改文件清单
```

### 3.4 文档质量要求

| 检查项 | 标准 | 检查方法 |
|--------|------|---------|
| **完整性** | 文档结构完整，不缺章节 | 对照模板检查 |
| **准确性** | 技术描述准确，无错误 | 技术Review |
| **可追溯性** | 每个决策有依据 | 检查参考资料 |
| **可验证性** | 验收标准可测试 | 用例验证 |
| **时效性** | 文档日期准确 | 检查时间戳 |

---

## 4. 测试规范

### 4.1 测试金字塔

```
        /\
       /  \
      / E2E \           端到端测试（少而精）
     /--------\
    / 集成测试 \         模块间交互（关键路径）
   /------------\
  /   单元测试    \      函数/组件（大量覆盖）
 /----------------\
```

### 4.2 必须测试的内容

- [ ] 正常路径（Happy Path）
- [ ] 边界值（最小值、最大值、空值）
- [ ] 异常输入（null、undefined、类型错误）
- [ ] 错误处理（异常抛出、错误码）

### 4.3 覆盖率要求

| 阶段 | 语句覆盖率 | 分支覆盖率 | 函数覆盖率 |
|------|-----------|-----------|-----------|
| MVP阶段 | ≥80% | ≥70% | ≥90% |
| 增强阶段 | ≥85% | ≥75% | ≥95% |
| 完善阶段 | ≥90% | ≥80% | ≥100% |

### 4.4 测试代码规范

**测试文件命名**:
- 前端: `ComponentName.test.tsx` 或 `*.spec.ts`
- 后端: `test_*.py` 或 `*_test.py`

**测试结构（Arrange-Act-Assert）**:
```python
def test_function():
    # Arrange（准备）
    input_data = ...
    expected = ...
    
    # Act（执行）
    result = function(input_data)
    
    # Assert（断言）
    assert result == expected
```

---

## 5. 代码审查规范（整合检查+风险分析）

### 5.1 审查清单（4个维度）

#### 维度1：逻辑正确性
- [ ] 功能是否符合设计文档
- [ ] 边界情况是否处理
- [ ] 错误处理是否完善
- [ ] 无明显逻辑错误

#### 维度2：代码质量
- [ ] 命名是否清晰（变量、函数、类）
- [ ] 是否有适当注释（非显而易见处）
- [ ] 是否符合代码规范（ESLint/Pylint）
- [ ] 是否有重复代码
- [ ] 代码结构是否清晰

#### 维度3：风险分析（基于《代码风险分析方法》六步法）
- [ ] 边界条件：null、空值、极值测试了吗？
- [ ] 异常情况：网络错误、权限不足处理了吗？
- [ ] 安全隐患：输入验证、XSS防护做了吗？
- [ ] 性能问题：有明显性能瓶颈吗？
- [ ] 资源泄漏：文件句柄、内存释放了吗？

#### 维度4：完整性
- [ ] 是否同步编写了单元测试
- [ ] 测试覆盖率是否达标
- [ ] 文档是否更新
- [ ] 无敏感信息泄露（密钥、密码）

### 5.2 闭环整改流程

```
发现问题
    ↓
记录问题（审查记录）
    ↓
修复问题
    ↓
验证修复（测试+审查）
    ↓
确认解决
    ↓
阶段才能继续
```

**规则**: 发现问题必须修复，不能遗留到下一阶段。

### 5.3 审查记录模板

```markdown
# 代码审查记录

**审查日期**: YYYY-MM-DD  
**审查人**: XXX  
**被审查代码**: 阶段X

## 审查发现

### 严重问题（必须修复）
1. 问题描述
   - 位置：文件路径，行号
   - 影响：... 
   - 建议：...

### 一般问题（建议修复）
1. 问题描述
   - 位置：...
   - 建议：...

## 审查结论
- [ ] 通过
- [ ] 有条件通过（需修复严重问题）
- [ ] 不通过（需全面修改）

## 修复验证
- [ ] 所有严重问题已修复
- [ ] 重新审查通过
```

---

## 6. 版本号与Git管理（整合版本规范+Git规范+备份规则）

### 6.1 语义化版本号

```
版本号 = MAJOR.MINOR.PATCH
         主版本.次版本.修订版本
```

| 版本位 | 变更场景 | 决策权限 | 阶段对应 |
|--------|----------|----------|---------|
| **MAJOR** | 重大架构变更 | 必须用户指令 | 项目里程碑（v1.0.0） |
| **MINOR** | 新功能模块 | 必须用户同意 | 大阶段完成（v0.1.0） |
| **PATCH** | Bug修复 | 可自主决定 | 阶段内补丁（v0.1.1） |

### 6.2 Git分支策略

| 分支类型 | 命名格式 | 用途 |
|---------|---------|------|
| **主线** | `main` | 稳定版本 |
| **阶段** | `phase/X.Y` | 阶段开发（如 `phase/1.1`） |
| **补丁** | `hotfix/描述` | 已锁定阶段紧急修复 |

**阶段操作流程**:
```bash
# 1. 阶段开始
git checkout -b phase/1.1 main

# 2. 阶段开发（多次commit）

# 3. 阶段完成
git checkout main
git merge phase/1.1
git tag -a v0.1.0-phase1.1 -m "阶段1.1完成"
git push origin v0.1.0-phase1.1
```

### 6.3 阶段锁定条件（必须全部满足）

1. ✅ 设计文档已归档
2. ✅ 测试报告（100%通过，覆盖率≥80%）
3. ✅ 审查记录（闭环整改完成）
4. ✅ 阶段总结已完成
5. ✅ **用户验收已通过**

**锁定后规则**:
- ❌ 严禁修改已锁定代码
- ❌ 严禁新增功能
- ✅ 如需修改走补丁流程

### 6.4 补丁流程（发现严重bug必须修复）

```
1. 用户批准修复
2. 创建补丁分支：git checkout -b hotfix/描述 v0.X.0-phaseN
3. 修复 + 补充测试
4. 审查 + 用户验收
5. 合并 + 新标签：v0.X.1-phaseN（PATCH+1）
```

---

## 7. 阶段跟踪与监控

### 7.1 阶段跟踪表

**文件名**: `阶段跟踪表.md`（根目录下，实时更新）

```markdown
# 阶段跟踪表

**最后更新**: YYYY-MM-DD HH:MM:SS

| 阶段 | 阶段名称 | 状态 | 设计文档 | 测试报告 | 阶段总结 | 锁定标签 | 验收人 |
|------|---------|------|---------|---------|---------|---------|--------|
| 1.0 | 项目骨架搭建 | ✅已锁定 | [链接] | [链接] | [链接] | v0.1.0-phase1 | XXX |
| 1.1 | 基础功能 | 🟡进行中 | [链接] | - | - | - | - |
| 1.2 | 增强功能 | ⏸️待启动 | - | - | - | - | - |

## 统计信息
- 总阶段数：X
- 已完成：Y
- 进行中：Z
- 待启动：W
```

### 7.2 每日状态更新

**规则**: 每天结束工作前，更新阶段跟踪表

**更新内容**:
- 当前阶段进展百分比
- 遇到的问题
- 需要的支持

---

## 8. 违规处理

### 8.1 违规行为及处理

| 违规行为 | 示例 | 处理措施 |
|---------|------|---------|
| **跳阶段开发** | 阶段1未完成就开始阶段2 | 立即停止，回退到上一阶段 |
| **无设计文档编码** | 直接写代码，后补文档 | 暂停开发，补全文档 |
| **无测试提交** | 功能代码无对应测试 | 拒绝合并，补充测试 |
| **审查问题不修复** | 发现问题不整改 | 阶段不通过，强制修复 |
| **用户未验收就锁定** | 用户未确认就标记完成 | 解锁，重新验收 |
| **修改已锁定代码** | 直接在已锁定代码上修改 | 回滚，走补丁流程 |

### 8.2 违规记录

**文件名**: `违规记录-YYYY-MM-DD.md`

```markdown
# 违规记录

**日期**: YYYY-MM-DD  
**违规人**: AI助手（小欧）  
**违规类型**: 跳阶段开发

## 违规描述
- 阶段1.1未完成，提前开始阶段1.2开发
- 具体行为：...

## 处理措施
1. 立即停止阶段1.2工作
2. 删除阶段1.2代码（已Git备份）
3. 回到阶段1.1继续完善
4. 补全阶段1.1缺失的测试

## 预防措施
- 加强阶段状态检查
- 每天核对阶段跟踪表
- 用户提醒机制

## 用户确认
- [ ] 处理完成，确认接受
```

---

## 9. 附录

### 9.1 术语表

| 术语 | 定义 |
|------|------|
| **阶段** | 有明确目标、可验收的独立开发单元 |
| **阶段锁定** | 阶段完成并归档，禁止修改 |
| **闭环整改** | 发现问题→修复→验证→解决 |
| **验收** | 用户确认阶段输出符合预期 |
| **覆盖率** | 测试代码覆盖的功能代码比例 |
| **补丁** | 对已锁定阶段的紧急修复 |
| **渐进式开发** | 分阶段推进，每个阶段可验证的增量 |

### 9.2 参考文档

- 《软件代码迭代规范》- 不求快只求稳，先分析再动手
- 《代码检查方法》- 闭环整改，代码审查维度
- 《代码风险分析方法》- 六步分析法
- 《版本号变更规范》- 语义化版本，分级授权
- 《git使用规范》- 分支策略
- 《软件迭代代码备份规则》- 备份时机

### 9.3 修订历史

| 版本 | 日期 | 修订人 | 修订内容 |
|------|------|--------|---------|
| v2.0 | 2026-02-15 | AI助手小欧 | 重构为两部分结构：第1-9章为核心基础规范，新增第10-17章为OmniAgent项目具体实施 |

---

# 第二部分：OmniAgent项目具体实施

---

## 10. OmniAgent项目概述

### 10.1 项目定位

OmniAgentAst. 桌面版是一款**本地运行的AI智能助手**，专为Windows桌面环境设计，能够在用户的电脑上自主执行任务、管理信息、协助工作。

**一句话描述**：*你的电脑里住进了一个聪明的数字助手，它会用你的软件、处理你的文件、帮你完成各种电脑上的繁琐工作。*

### 10.2 与原版AI_OSShell_v2的关系

**继承**：
- ReAct智能循环架构
- 工具调用机制
- 本地命令执行能力

**升级**：
- 桌面GUI替代Web界面
- 配置化管理替代硬编码
- 安全确认机制
- 持久化存储

### 10.3 技术栈选择

| 层级 | 技术选型 | 选择理由 |
|------|---------|---------|
| **桌面UI** | Tauri (Rust) + React | 体积小(几MB)、性能好、现代Web技术 |
| **后端核心** | Python 3.11+ | AI生态完善、现有代码可复用 |
| **AI接口** | 智谱GLM (默认) + Claude (备选) | 智谱免费稳定 + Claude作为国外备选 |
| **数据存储** | SQLite + Local Vector DB | 零配置、单文件、易备份 |
| **配置管理** | YAML | 人类可读、易编辑、支持注释 |

### 10.4 混合架构设计

针对Windows桌面环境的复杂性（软件千差万别、操作不确定性强），采用**三层混合架构**：

| 架构层 | 采用模式 | 解决问题 | 占比 |
|--------|---------|---------|------|
| **规划层** | Plan-and-Execute | 任务分解、批量执行 | 60% |
| **执行层** | ReAct | 动态调整、错误恢复 | 30% |
| **优化层** | Reflection | 质量提升、复杂修复 | 10% |

**工作流程**：
```
用户输入 → Planner(生成计划) → 用户确认 → Executor(ReAct执行) 
                                              ↓
                                           成功 → 完成
                                              ↓
                                           失败 → Refiner(分析修复) → 重试
```

---

## 11. 开发阶段规划

### 11.1 第一阶段：Web端核心功能（MVP）

**阶段目标**：搭建Web端基础框架，实现核心ReAct循环和基础工具，验证AI模型调用和工具执行能力。

**验收标准**：
- [ ] 基础架构搭建完成（Flask/FastAPI + React）
- [ ] 智谱GLM API集成成功
- [ ] ReAct循环正常运行
- [ ] P0级工具实现（read_file, write_file, list_directory, move_file）
- [ ] 基础对话界面可用
- [ ] 配置管理功能正常
- [ ] 安全机制（命令黑名单、确认机制）生效

**阶段1详细任务**：

| 子阶段 | 任务 | 验收标准 |
|--------|------|---------|
| 1.1 | 基础架构搭建 | 前后端能正常通信，健康检查接口可用 |
| 1.2 | AI模型接入 | 能成功调用智谱GLM API，返回正常响应 |
| 1.3 | ReAct执行器 | 能完成思考-行动-观察循环，工具调用成功 |
| 1.4 | P0工具实现 | 4个基础文件操作工具可用，有完整测试 |
| 1.5 | 对话界面 | 能发送消息、接收回复、展示执行过程 |
| 1.6 | 安全配置 | 危险命令被拦截，敏感操作需确认 |

### 11.2 第二阶段：功能增强与P1工具

**阶段目标**：扩展工具集，增强功能，提升用户体验。

**验收标准**：
- [ ] P1级工具实现（list_windows, switch_window, screenshot, run_shell, create_directory, delete_file）
- [ ] Planner规划器（简化版）可用
- [ ] 对话历史管理（SQLite存储）
- [ ] 会话恢复功能

### 11.3 第三阶段：桌面客户端包装

**阶段目标**：将Web端用Tauri打包为桌面应用，增加系统级功能。

**验收标准**：
- [ ] Tauri基础集成成功
- [ ] Python后端能自动启动
- [ ] 系统托盘功能正常
- [ ] 全局快捷键生效（Ctrl+Shift+O）
- [ ] Windows安装程序可用

### 11.4 第四阶段：高级功能（后续规划）

**阶段目标**：实现高级功能，提升智能化水平。

**功能列表**：
- Refiner优化器（失败自动修复）
- 浏览器自动化
- 知识库功能（向量索引、语义搜索）
- 多模型智能切换

---

## 12. 架构设计实施

### 12.1 系统分层架构

```
┌─────────────────────────────────────────────────────────────┐
│                    用户界面层 (UI Layer)                      │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │
│  │  主聊天窗口   │  │  系统托盘     │  │  快捷指令    │       │
│  │  (对话交互)   │  │  (后台常驻)   │  │  (快捷键)    │       │
│  └──────────────┘  └──────────────┘  └──────────────┘       │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                   核心引擎层 (Core Engine)                    │
│  ┌─────────────────┐  ┌─────────────────┐                   │
│  │   AI Agent      │  │   任务管理器     │                   │
│  │   (ReAct循环)   │  │   (队列+状态)    │                   │
│  └─────────────────┘  └─────────────────┘                   │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                    工具层 (Tools Layer)                       │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐       │
│  │ 文件操作  │ │ 系统命令  │ │ 浏览器   │ │ 应用程序  │       │
│  │ 读写/管理 │ │ 执行/脚本 │ │ 自动化   │ │ 控制     │       │
│  └──────────┘ └──────────┘ └──────────┘ └──────────┘       │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                   数据层 (Data Layer)                         │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │
│  │  对话历史     │  │  配置文件     │  │  知识库      │       │
│  │  SQLite      │  │  YAML/JSON   │  │  本地向量库   │       │
│  └──────────────┘  └──────────────┘  └──────────────┘       │
└─────────────────────────────────────────────────────────────┘
```

### 12.2 Planner实现规范

**职责**：一次性生成完整执行计划

**实现要求**：
- 调用AI分析用户意图
- 分解为可执行步骤
- 标注关键步骤（失败需人工干预）
- 用户确认后执行

**验收标准**：
- [ ] 能正确理解用户意图
- [ ] 生成的计划步骤清晰可执行
- [ ] 关键步骤标注准确
- [ ] 用户可预览和取消计划

### 12.3 ReAct Executor实现规范

**职责**：每步动态调整，失败自动重试

**实现要求**：
- Thought（思考）→ Action（行动）→ Observation（观察）循环
- 每步最多重试3次
- 记录失败上下文供Refiner分析
- 单步失败不中断整个任务

**验收标准**：
- [ ] 循环逻辑正确
- [ ] 重试机制生效
- [ ] 失败信息记录完整
- [ ] 用户可暂停/取消任务

### 12.4 Refiner实现规范

**职责**：深度分析失败原因，生成修复策略

**触发条件**：
- 同一任务连续失败2次
- 用户明确反馈"不对"
- 结果质量评分低于0.7

**实现要求**：
- 分析失败模式和根因
- 生成新的执行策略
- 提供用户可理解的解释

**验收标准**：
- [ ] 能准确分析失败原因
- [ ] 生成的修复策略有效
- [ ] 用户能理解分析结果

---

## 13. 工具框架实施

### 13.1 工具定义Schema

每个工具必须包含：
```python
{
    "name": "工具名称",
    "description": "功能描述",
    "parameters": {
        "param1": {"type": "string", "description": "..."}
    },
    "danger_level": "low|medium|high",  # 风险等级
    "examples": ["使用示例1", "使用示例2"]
}
```

### 13.2 P0级工具（必须实现）

| 工具 | 功能 | 风险等级 | 验收标准 |
|------|------|---------|---------|
| `read_file` | 读取文件内容 | low | 能正确读取文本、图片、PDF |
| `write_file` | 写入/创建文件 | medium | 支持覆盖/追加模式，有确认 |
| `list_directory` | 列出目录内容 | low | 返回文件列表，支持过滤 |
| `move_file` | 移动/重命名文件 | medium | 支持跨目录移动，有确认 |

### 13.3 P1级工具（阶段2实现）

| 工具 | 功能 | 风险等级 | 验收标准 |
|------|------|---------|---------|
| `list_windows` | 列出所有窗口 | low | 返回窗口标题和句柄 |
| `switch_window` | 切换到指定窗口 | low | 能正确激活窗口 |
| `screenshot` | 截图当前屏幕/窗口 | low | 支持全屏/窗口/区域截图 |
| `run_shell` | 执行shell命令 | high | 有黑名单检查，危险命令需确认 |
| `create_directory` | 创建文件夹 | low | 支持递归创建 |
| `delete_file` | 删除文件 | high | 必须确认，支持回收站 |

### 13.4 工具安全分级

| 等级 | 操作示例 | 处理方式 |
|------|---------|---------|
| **🟢 安全** | 读取文件、查询信息、打开应用 | 直接执行 |
| **🟡 注意** | 修改文件、创建文件夹、复制移动 | 通知用户，可撤销 |
| **🟠 谨慎** | 执行命令、删除文件、网络请求 | 必须确认，显示详情 |
| **🔴 危险** | 格式化、修改系统配置、执行脚本 | 禁止自动执行 |

### 13.5 Shell命令黑名单

**禁止执行的命令**：
```yaml
shell_blacklist:
  - "rm -rf /"
  - "rm -rf /*"
  - "format"
  - "mkfs"
  - "dd if=/dev/zero"
  - ":(){ :|:& };:"  # fork炸弹
  - "del /f /s /q"
```

---

## 14. UI实施规范

### 14.1 界面布局

```
┌────────────────────────────────────────────────────────────┐
│  OmniAgentAst.                              [_] [□] [X]   │
├────────────┬───────────────────────────────────────────────┤
│            │                                               │
│  📁 文件    │    🤖 今天有什么可以帮你的？                   │
│  🖥️ 系统    │                                               │
│  🌐 浏览器  │    ┌─────────────────────────────────────┐   │
│  📚 知识库  │    │ 用户: 帮我整理下载文件夹               │   │
│  ⚙️ 设置    │    │                                       │   │
│            │    │ Agent: 好的，我发现下载文件夹有:        │   │
│ ───────────│    │ - 15个压缩包 (.zip/.rar)               │   │
│  💬 历史    │    │ - 23个文档 (.pdf/.doc)                 │   │
│  🔧 快捷    │    │ - 8个安装包 (.exe/.msi)                │   │
│            │    │                                       │   │
│            │    │ 建议按类型分3个文件夹存放，执行吗？      │   │
│            │    │ [执行] [查看详情] [取消]                │   │
│            │    └─────────────────────────────────────┘   │
│            │                                               │
│            │    ┌─────────────────────────────────────┐   │
│            │    │ > 帮我截图当前窗口并保存到桌面         │   │
│            │    └─────────────────────────────────────┘   │
│            │                    [发送]                     │
└────────────┴───────────────────────────────────────────────┘
```

### 14.2 交互设计原则

**1. 透明可见**
- Agent执行任何操作前，显示"准备做什么"
- 高危操作显示确认对话框
- 任务进度实时显示

**2. 随时接管**
- 任何时候可以打断Agent
- 提供"暂停"、"取消"按钮
- 错误时清晰说明原因

**3. 渐进授权**
- 低风险：直接执行
- 中风险：通知用户
- 高风险：必须确认
- 极高风险：禁止执行

### 14.3 消息展示规范

**用户消息**：
- 右侧对齐
- 蓝色背景
- 显示发送时间

**Agent消息**：
- 左侧对齐
- 灰色背景
- 显示思考过程（可折叠）
- 显示工具调用信息
- 显示执行结果

**系统消息**：
- 居中
- 灰色小字
- 提示状态变化

---

## 15. 安全实施规范

### 15.1 本地安全模型

**核心原则**：用户完全控制自己的电脑，Agent只是协助者

```
┌──────────────────────────────────────┐
│          桌面版安全架构               │
├──────────────────────────────────────┤
│                                      │
│  用户 ←── 完全控制 ──→ 电脑系统       │
│   ↑                                  │
│   │ 授权                             │
│   ↓                                  │
│  Agent ←── 受限操作 ──→ 特定功能      │
│                                      │
│  安全边界: 用户明确授权 + 风险分级     │
│                                      │
└──────────────────────────────────────┘
```

### 15.2 隐私保护

**本地优先策略**：
- ✅ 所有数据本地存储
- ✅ 配置文件本地保存
- ✅ API Key仅保存在用户电脑
- ✅ 可选：对话历史不上传
- ✅ 知识库完全离线

**可选云端功能**（默认关闭）：
- 云端备份（用户主动开启）
- 跨设备同步（需账号系统）

### 15.3 安全配置

**settings.yaml安全相关配置**：
```yaml
security:
  confirm_destructive: true      # 破坏性操作需确认
  max_retry_attempts: 3          # 最大重试次数
  shell_whitelist: []            # 允许的命令白名单
  shell_blacklist:               # 禁止的命令黑名单
    - "rm -rf /"
    - "format"
    - "mkfs"
```

---

## 16. 数据存储实施

### 16.1 存储结构

```
~/OmniAgentAst/
├── config/
│   ├── settings.yaml          # 用户配置
│   ├── api_keys.yaml          # API密钥 (加密存储)
│   └── shortcuts.yaml         # 快捷指令
│
├── data/
│   ├── conversations.db       # SQLite对话历史
│   ├── knowledge.db           # 知识库向量数据
│   └── cache/                 # 临时缓存
│
├── logs/
│   ├── app.log               # 运行日志
│   └── errors.log            # 错误日志
│
└── plugins/                  # 插件目录
    └── custom_tools/
```

### 16.2 对话历史存储

**SQLite表结构**：
```sql
CREATE TABLE conversations (
    id INTEGER PRIMARY KEY,
    title TEXT,
    created_at TIMESTAMP,
    updated_at TIMESTAMP
);

CREATE TABLE messages (
    id INTEGER PRIMARY KEY,
    conversation_id INTEGER,
    role TEXT,  -- 'user' | 'assistant' | 'system'
    content TEXT,
    tool_calls TEXT,  -- JSON格式存储工具调用
    created_at TIMESTAMP,
    FOREIGN KEY (conversation_id) REFERENCES conversations(id)
);
```

### 16.3 配置管理

**配置加载优先级**（从高到低）：
1. 用户配置文件（~/OmniAgentAst/config/settings.yaml）
2. 项目默认配置（项目目录/config/default.yaml）
3. 代码硬编码默认值

**配置热更新**：
- 监听配置文件变化
- 变化后自动重新加载
- 无需重启应用

---

## 17. 项目特定标准

### 17.1 AI模型策略

**默认模型：智谱AI (BigModel)**
- 模型：glm-4.7-flash
- 优点：国内访问稳定、免费、中文优化好
- 适用：日常对话、基础工具调用

**备选模型：Claude 3.5 Sonnet**
- 优点：工具调用能力强、上下文长(200K)
- 适用：复杂任务、需要强推理能力
- 缺点：国内访问需代理、价格较高

**智能切换配置**：
```yaml
ai:
  strategy: "smart"  # smart | force_zhipuai | force_claude
  
  zhipuai:
    model: "glm-4.7-flash"
    api_key: "your-api-key"
  
  claude:
    model: "claude-3-5-sonnet-20241022"
    api_key: "your-api-key"
```

### 17.2 代码组织规范

**后端目录结构**：
```
omniagent_backend/
├── app/
│   ├── __init__.py
│   ├── main.py              # FastAPI/Flask入口
│   ├── api/                 # API路由
│   ├── core/                # 核心逻辑
│   │   ├── agent.py         # ReAct循环
│   │   ├── planner.py       # 计划生成器
│   │   └── refiner.py       # 优化器
│   ├── tools/               # 工具实现
│   │   ├── file_tools.py
│   │   ├── system_tools.py
│   │   └── __init__.py
│   ├── models/              # 数据模型
│   └── utils/               # 工具函数
├── config/
│   └── default.yaml
├── tests/
│   ├── unit/
│   └── integration/
└── requirements.txt
```

**前端目录结构**：
```
omniagent_frontend/
├── src/
│   ├── components/          # React组件
│   ├── pages/              # 页面
│   ├── hooks/              # 自定义Hooks
│   ├── services/           # API调用
│   ├── stores/             # 状态管理
│   └── utils/              # 工具函数
├── public/
└── package.json
```

### 17.3 测试策略

**单元测试**：
- 每个工具函数必须有测试
- 使用pytest（后端）/ Jest（前端）
- 覆盖率≥80%

**集成测试**：
- API接口测试
- 前后端通信测试
- 使用pytest-asyncio / React Testing Library

**端到端测试**：
- 关键用户流程测试
- 使用Playwright
- 覆盖主要功能场景

### 17.4 文档要求

**每个阶段必须产出**：
1. 设计文档（编码前）
2. 测试报告（测试后）
3. 阶段总结（验收前）

**API文档**：
- 使用OpenAPI/Swagger
- 每个接口有示例请求/响应
- 错误码说明

**代码注释**：
- 函数必须有docstring
- 复杂逻辑需注释说明
- 类型注解完整

### 17.5 性能基准

**响应时间要求**：
- 简单查询：< 500ms
- 文件操作：< 1s
- AI对话响应：< 3s
- 复杂任务计划：< 5s

**资源占用限制**：
- 内存：< 500MB（空闲时< 100MB）
- CPU：< 10%（空闲时< 1%）
- 安装包大小：< 100MB

---

## 附录A：与原版AI_OSShell_v2对比

| 方面 | AI_OSShell_v2 | OmniAgentAst. 个人版 |
|------|---------------|---------------------|
| **部署** | 本地Web服务 | 桌面应用 |
| **用户** | 单用户 | 单用户（个人） |
| **界面** | 浏览器页面 | 原生桌面GUI |
| **配置** | 硬编码Python | YAML配置文件 |
| **安全** | 无 | 风险分级确认 |
| **存储** | 内存 | SQLite持久化 |
| **工具** | 4个基础工具 | 10+工具 + 插件 |
| **知识库** | 无 | 本地向量库 |
| **扩展** | 改代码 | 插件系统 |

---

## 附录B：经验来源文档清单

**第一部分规范来源**：
1. 《软件代码迭代规范》- 渐进式开发策略、质量优先原则
2. 《代码检查方法》- 闭环整改、审查维度
3. 《代码风险分析方法》- 风险分析六步法
4. 《版本号变更规范》- 语义化版本、分级授权
5. 《git使用规范》- 分支策略、提交规范
6. 《软件迭代代码备份规则》- 备份时机、目录命名

**第二部分实施来源**：
7. 《开发优先级计划》- 阶段划分、任务分解
8. 《OmniAgentAst_桌面版设计方案》- 架构设计、技术选型
9. 原版`AI_OSShell_v2.py` - 核心逻辑参考

---

## 修订历史

| 版本 | 日期 | 修订人 | 修订内容 |
|------|------|--------|---------|
| v1.0 | 2026-02-15 22:05:53 | AI助手小欧 | 初始版本，9章核心基础规范 |
| v2.0 | 2026-02-15 22:30:00 | AI助手小欧 | 重构为两部分结构：第1-9章为核心基础规范，第10-17章为OmniAgent项目具体实施；整合6份历史经验文档，融入项目设计方案和开发计划 |

---

**文档结束**

**重要提醒**: 
- 本文档共17章，分为两部分
- 第一部分（1-9章）：通用核心基础规范，适用于所有渐进式开发项目
- 第二部分（10-17章）：OmniAgentAst.桌面版项目具体实施规范
- 流程精简但完整，每个环节都必须执行
- 闭环整改是核心，问题必须修复

**用户确认**:
- [ ] 已阅读全文（第1-17章）
- [ ] 理解文档两部分结构
- [ ] 理解每个环节都必须执行
- [ ] 确认按此规范执行开发

**确认人**: _______________  
**确认日期**: YYYY-MM-DD
