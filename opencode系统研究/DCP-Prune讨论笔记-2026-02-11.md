# DCP-Prune讨论笔记-2026-02-11

**创建时间**: 2026-02-11 11:25:02  
**存放位置**: D:\2bktest\MDview\

---

## 1 DCP Prune机制说明 【讨论背景】2026-02-11 11:25:02

### 1.1 什么是Prune

Prune是OpenCode的上下文管理工具，用于删除对话中不再需要的工具输出，释放上下文空间。

### 1.2 Prune的工作原理

| 行为 | 说明 |
|------|------|
| **删除内容** | 只删除对话上下文中的工具输出显示 |
| **不删除文件** | 不会删除实际存放在磁盘上的数据文件 |

---

## 2 不同工具的Prune风险 【工具分类】2026-02-11 11:25:02

### 2.1 安全的（保存到磁盘）

| 工具 | 保存位置 | Prune后影响 |
|------|---------|-------------|
| `webfetch` | `tool-output/` 目录 | ✅ 无影响，可重新读取 |
| `google_search` | `tool-output/` 目录 | ✅ 无影响，可重新读取 |
| API调用结果 | `tool-output/` 目录 | ✅ 无影响 |

**说明**：`webfetch`和`google_search`的区别：
- `webfetch`：已知具体URL，直接获取网页内容
- `google_search`：搜索关键词，返回搜索结果和来源链接
- 两者都会保存到磁盘，**都是安全的**

### 2.2 有风险的（只在内存）

| 工具 | 数据位置 | Prune后影响 |
|------|---------|-------------|
| `read` | 内存 | ⚠️ **内容丢失** |
| `bash` | 内存 | ⚠️ **输出丢失** |
| `grep/glob` | 内存 | ⚠️ **结果丢失** |

### 2.3 风险场景示例

```
1. read 读取了重要配置文件
2. 还没处理完，被 prune 删掉了
3. 后续想引用那个配置内容 → 找不到了！
```

---

## 3 避免Prune干扰的方法 【最佳实践】2026-02-11 11:25:02

### 3.1 三种避免方法

| 方法 | 操作 | 适用场景 |
|------|------|---------|
| **方法1: distill** | 用 `distill` 精炼核心信息 | 长内容，只需保留关键点 |
| **方法2: 写文件** | 写入临时文件保存 | 需要完整内容后续使用 |
| **方法3: 延迟prune** | 任务完成前不prune相关输出 | 还在处理中的内容 |

### 3.2 工作流程建议

```
正确流程：
1. 获取信息（read/bash/grep）
2. 立即处理或保存关键信息
3. 确认不再需要原始输出后，再prune
4. 不要在任务中途prune可能还需要的内容
```

### 3.3 判断是否可以Prune

| 情况 | 是否可以Prune |
|------|:------------:|
| 信息已处理完毕 | ✅ 可以 |
| 已用distill精炼 | ✅ 可以 |
| 已写入文件保存 | ✅ 可以 |
| 任务还在进行中 | ❌ 不可以 |
| 后续可能还要引用 | ❌ 不可以 |
| 不确定是否还需要 | ❌ 先不prune |

---

## 4 实际案例 【本会话经验】2026-02-11 11:25:02

### 4.1 安全案例

```
webfetch 获取 OpenRouter API 数据
  ↓
自动保存到 tool-output/tool_c4a6fb58b001tcWLUvk3o9aFdx
  ↓
被 prune 删除了对话中的显示
  ↓
但文件还在磁盘上，可以重新读取 ✅
```

### 4.2 风险案例（假设）

```
read 读取了一个配置文件
  ↓
还没来得及处理
  ↓
被 prune 删除了
  ↓
后续想引用配置内容 → 需要重新 read ❌
```

### 4.3 图片生成被打劫案例（真实）2026-02-11

**问题描述**：
在生成图片时，有一种生成方法是调用工具先生成图片数据，然后数据刚生成就被prune打劫删除了。

**问题流程**：
```
调用图片生成工具
  ↓
生成图片数据（base64或二进制）
  ↓
数据量大，触发prune机制
  ↓
图片数据被删除 ❌
  ↓
后续处理找不到图片数据
```

**影响**：
- 图片生成失败或不完整
- 需要重新生成，浪费时间和资源
- 用户体验差

**原因分析**：
- 图片数据（base64）通常很大
- 大量数据可能触发自动prune
- 图片生成工具可能不会自动保存到磁盘

**解决方案**：
| 方案 | 说明 |
|------|------|
| **方案1** | 图片生成后立即写入文件保存 |
| **方案2** | 生成时指定输出文件路径 |
| **方案3** | 在图片生成任务完成前禁用自动prune |

---

## 5 大模型如何主动避免被打劫 【AI操作规范】2026-02-11 11:38:17

**重要**：用户无法控制prune，大模型在调度工具时必须主动避免被打劫。

### 5.1 大模型必须遵守的操作规范

| 规范 | 说明 |
|------|------|
| **规范1: 立即处理** | 获取数据后立即处理，不要等到后续步骤 |
| **规范2: 先保存再prune** | 重要数据先写入文件或用distill精炼，再考虑prune |
| **规范3: 任务完成前不prune** | 当前任务还在进行中，不要prune相关输出 |
| **规范4: 图片数据特殊处理** | 图片生成后必须立即写入文件保存 |
| **规范5: 大数据量警惕** | 预估输出量大时，优先考虑保存到文件 |

### 5.2 具体操作方法

```
read/bash/grep 操作：
  1. 执行工具获取数据
  2. 立即处理数据（不要等）
  3. 如果需要保留，用write写入文件或用distill精炼
  4. 确认处理完毕后，才能prune

图片生成操作：
  1. 调用图片生成工具时，指定输出文件路径
  2. 或生成后立即写入文件
  3. 不要让大数据在内存中停留

多步骤任务：
  1. 识别任务需要哪些中间数据
  2. 关键中间数据必须保存到文件
  3. 任务全部完成后再prune
```

### 5.3 风险识别清单

| 情况 | 风险等级 | 处理方法 |
|------|:--------:|---------|
| 输出量可能很大 | ⚠️ 高 | 优先写入文件 |
| 需要多步骤处理 | ⚠️ 高 | 中间数据保存 |
| 图片/二进制数据 | ⚠️ 高 | 立即写文件 |
| 需要后续引用 | ⚠️ 中 | 用distill或写文件 |
| 一次性使用 | ✅ 低 | 可以prune |

---

## 6 总结 【核心原则】2026-02-11 11:38:17

### 6.1 核心原则

| 原则 | 说明 |
|------|------|
| **任务未完成不prune** | 中途不要删除可能还需要的内容 |
| **重要内容先保存** | 用distill精炼或写入文件 |
| **webfetch类安全** | 自动保存到磁盘，可重新读取 |
| **read/bash类需注意** | 只在内存，prune后丢失 |

### 6.2 简记口诀

```
webfetch 安全放心
read/bash 要小心
任务没完别prune
重要内容先保存
```

---

## 7. 关键发现：permission不控制自动策略

**时间**: 2026-02-11 13:00:40

### 7.1 问题现象

用户将 `tools.prune.permission` 设置为 `"ask"`，但从昨天到今天一次都没问过。

### 7.2 根因分析

通过查看DCP官方schema文件发现：

| 配置项 | 作用 | 受permission控制？ |
|--------|------|------------------|
| `tools.prune` | 手动调用prune工具 | ✅ 受控制 |
| `tools.distill` | 手动调用distill工具 | ✅ 受控制 |
| `tools.compress` | 手动调用compress工具 | ✅ 受控制 |
| `strategies.deduplication` | **自动去重** | ❌ 不受控制 |
| `strategies.supersedeWrites` | **自动删除被覆盖的写入** | ❌ 不受控制 |
| `strategies.purgeErrors` | **自动清理错误** | ❌ 不受控制 |

**核心结论**：

> `permission` 只控制**手动调用工具**时的行为，**自动策略独立运行，不受permission控制！**

### 7.3 真相

你看到的prune操作，大部分是**自动策略**在运行，不是prune工具在运行。

所以即使设置了 `"permission": "ask"`，自动策略仍然会：
- 自动去重
- 自动删除被覆盖的写入
- 自动清理错误

### 7.4 正确的解决方法

要真正减少被打劫，需要**关闭自动策略**：

```json
{
  "strategies": {
    "deduplication": { "enabled": false },
    "supersedeWrites": { "enabled": false },
    "purgeErrors": { "enabled": false }
  }
}
```

**但注意**：关闭所有策略会导致上下文快速膨胀。

### 7.5 推荐配置

| 策略 | 建议设置 | 理由 |
|------|---------|------|
| `deduplication` | `true` | 去重是合理的，减少冗余 |
| `supersedeWrites` | `false` | 保留写入记录，方便调试 |
| `purgeErrors` | `true`, `turns: 15` | 延长错误保留时间 |

---

## 8. DCP策略核心概念详解 【深入理解】2026-02-11 13:26:57

### 8.1 上下文结构图

```
┌─────────────────────────────────────────┐
│            上下文（200K）                 │
├─────────────────────────────────────────┤
│  用户消息                                │
│  AI回复                                  │
│  ┌───────────────────────────────────┐  │
│  │ 工具调用记录                        │  │
│  │  - read: xxx                       │  │
│  │  - write: xxx  ← 写入记录          │  │
│  │  - edit: xxx                       │  │
│  │  - bash: xxx                       │  │
│  └───────────────────────────────────┘  │
└─────────────────────────────────────────┘
```

**说明**：
- **上下文** = 整个对话的"记忆容量"（200K tokens）
- **工具调用记录** = 上下文中的一部分，记录了所有工具操作
- **写入记录** = 工具调用记录的子集，专门记录文件写入操作

---

### 8.2 supersedeWrites（覆盖写入）详解

#### 什么是写入记录？

```
对话上下文 = 你的消息 + 我的回复 + 工具调用记录
                                    ↓
                         ┌─────────────────────────┐
                         │  工具调用记录（会占用上下文） │
                         ├─────────────────────────┤
                         │ read: 文件内容          │
                         │ write: 写入了什么内容    │  ← 这就是"写入记录"
                         │ bash: 命令输出          │
                         │ edit: 修改了什么         │
                         └─────────────────────────┘
```

#### 举例说明

```
我说：读取A.txt
→ 工具调用：read A.txt
→ 上下文中增加一条记录：read A.txt 的内容

我说：写入B.txt
→ 工具调用：write B.txt
→ 上下文中增加一条记录：write B.txt 写入了xxx内容  ← 这就是写入记录
```

#### supersedeWrites 的作用

```
场景：我多次修改同一个文件

第1次：edit A.txt（改了第10行）
第2次：edit A.txt（改了第20行）
第3次：edit A.txt（改了第30行）

上下文中的记录：
- edit A.txt 第1次的完整内容  ← 占用上下文
- edit A.txt 第2次的完整内容  ← 占用上下文
- edit A.txt 第3次的完整内容  ← 占用上下文

如果 supersedeWrites = true：
  → 只保留第3次的记录，删除前2次
  → 节省上下文空间
  → 但丢失了修改历史

如果 supersedeWrites = false：
  → 3次记录都保留
  → 占用更多上下文
  → 但可以追溯修改历史
```

---

### 8.3 purgeErrors（清理错误）详解

#### 错误是什么？

```
错误 = 工具调用失败时的错误信息

例如：
- read: 文件不存在 → 产生错误记录
- write: 权限不足 → 产生错误记录
- bash: 命令执行失败 → 产生错误记录
- edit: 找不到oldString → 产生错误记录
```

#### purgeErrors 的作用

```
场景：调试时多次失败

第1轮：read A.txt → 失败，文件不存在
第2轮：read B.txt → 失败，权限不足
第3轮：read C.txt → 成功

上下文中的错误记录：
- 第1轮的错误信息
- 第2轮的错误信息

如果 purgeErrors 开启：
  → 几轮对话后自动删除这些错误记录
  → 节省上下文空间
  → 但丢失了错误历史

如果 purgeErrors 关闭：
  → 错误记录一直保留
  → 占用上下文
  → 但可以回顾调试过程
```

#### 为什么要保留错误？

| 保留原因 | 说明 |
|---------|------|
| **调试追溯** | 可以回顾之前为什么失败 |
| **学习改进** | 知道哪些方法行不通 |
| **问题分析** | 错误信息可能包含重要线索 |

---

### 8.4 deduplication（去重）详解

#### 什么是重复的工具调用？

```
场景：多次读取同一个文件

第1次：read A.txt → 返回文件内容
第2次：read A.txt → 返回相同内容（重复）
第3次：read A.txt → 返回相同内容（重复）

如果 deduplication = true：
  → 只保留最新的调用记录
  → 删除之前的重复调用
  → 节省上下文空间

如果 deduplication = false：
  → 所有调用记录都保留
  → 浪费上下文空间
```

---

### 8.5 三个策略对比总结

| 策略 | 处理什么 | 开启后 | 关闭后 | 建议 |
|------|---------|--------|--------|------|
| **deduplication** | 重复的工具调用 | 只保留最新一次 | 保留所有重复调用 | ✅ 开启 |
| **supersedeWrites** | 文件写入记录 | 只保留最新写入 | 保留所有写入历史 | ❌ 关闭 |
| **purgeErrors** | 工具调用错误 | N轮后自动清理 | 保留所有错误记录 | ✅ 开启，延长到15轮 |

---

### 8.6 写入记录 vs 上下文的关系

```
┌─────────────────────────────────────────┐
│            上下文（200K）                 │
├─────────────────────────────────────────┤
│  用户消息                                │
│  AI回复                                  │
│  ┌───────────────────────────────────┐  │
│  │ 工具调用记录                        │  │
│  │  - read: xxx                       │  │
│  │  - write: xxx  ← 写入记录          │  │ ← 写入记录是上下文的子集
│  │  - edit: xxx                       │  │
│  │  - bash: xxx                       │  │
│  └───────────────────────────────────┘  │
└─────────────────────────────────────────┘
```

| 概念 | 说明 |
|------|------|
| **上下文** | 整个对话的"记忆容量"（200K tokens） |
| **写入记录** | 上下文中的一部分，记录了文件操作的内容 |
| **关系** | 写入记录是上下文的子集 |

---

### 8.7 当前配置及理由

```json
{
  "deduplication": { "enabled": true },   // ✅ 保留：去重合理
  "supersedeWrites": { "enabled": false }, // ✅ 关闭：保留写入历史
  "purgeErrors": { "enabled": true, "turns": 10 } // ✅ 保留：10轮后清理
}
```

| 策略 | 状态 | 理由 |
|------|------|------|
| deduplication | 开 | 相同操作去重，节省空间，不会丢失重要信息 |
| supersedeWrites | 关 | 保留修改历史，方便调试和追溯问题 |
| purgeErrors | 开 | 错误信息保留10轮，够用了，太久也没意义 |

---

**更新时间**: 2026-02-11 13:26:57
