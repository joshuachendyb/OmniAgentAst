# 使用 Git 的代码管理流程及方法

**创建时间**: 2026-02-04 21:09:09
**版本**: 1.0

## 1. 项目初始化

**步骤1：创建 Git 仓库**
```bash
# 你的指令：初始化 **项目** git 仓库
git init  # 初始化本地仓库
git add . # 添加所有文件到暂存区
git commit -m "init: 项目初始化"  # 提交初始代码
git branch -M main  # 将默认分支重命名为 main
```

**步骤2：设置 Git 配置（用于记录代码提交者信息）**
```bash
git config user.name "AI助手小欧"  # 设置提交用户名，用于记录谁提交了代码
```

## 2. 功能新增或完善迭代开发

### 2.1 功能需求分析与确认
```bash
# 你的指令：开始用户登录功能
# 我的操作如下：
git checkout -b feature/用户登录  # 创建并切换到功能分支
需求分析和设计  # 进行用户登录功能的需求分析和设计
通知你确认需求分析和设计  # 通知你确认需求分析和设计
```

### 2.2 功能开发与单元测试
```bash
# 你的确认：确认需求分析和设计
# 我的操作如下：
代码开发  # 开始用户登录功能的代码开发
代码检查和单元测试  # 进行代码检查和运行单元测试
通知你功能开发完成  # 报告你用户登录功能开发完成
```

### 2.3 功能集成测试与代码提交，版本更新
```bash
# 你的下命令：进行最终集成和回归测试
# 我的操作如下：
# 自动构建项目  # 构建项目验证
# 自动进行回归测试  # 运行整体功能测试
# 自动运行集成测试  # 运行模块间交互的测试
git checkout main  # 切换到主分支
git merge feature/用户登录  # 合并功能分支
git add .  # 添加所有文件到暂存区
git commit -m "feat: 用户登录功能"  # 提交代码
git tag v1.2.0  # 更新版本标签
```

## 3. BUG 修复流程

### 3.1 Bug分析与修改方法确认
```bash
# 你的指令：修复登录失败问题
# 我的操作如下：
git checkout -b bugfix/登录失败  # 创建并切换到修复分支
Bug分析与修改方法确认  # 分析Bug原因和位置，确定修复方案
通知你确认Bug分析与修改方法  # 通知你确认Bug分析和修复方案
```

### 3.2 Bug修复与单元测试
```bash
# 你的确认：确认Bug分析与修改方法
# 我的操作如下：
Bug修复  # 开始登录失败问题的Bug修复
代码检查和单元测试  # 进行代码检查和运行单元测试
通知你Bug修复完成  # 报告你登录失败问题修复完成
```

### 3.3 Bug集成测试与代码提交，版本更新
```bash
# 你的下命令：进行最终集成和回归测试
# 我的操作如下：
# 自动构建项目  # 构建项目验证
# 自动进行回归测试  # 运行整体功能测试
# 自动运行集成测试  # 运行模块间交互的测试
git checkout main  # 切换到主分支
git merge bugfix/登录失败  # 合并修复分支
git add .  # 添加所有文件到暂存区
git commit -m "fix: 修复登录失败问题"  # 提交代码
git tag v1.2.1  # 更新版本标签
```

## 4. 代码重构流程

### 4.1 重构需求分析与确认
```bash
# 你的指令：重构用户模块代码
# 我的操作如下：
git checkout -b refactor/用户模块  # 创建并切换到重构分支
重构需求分析和设计  # 进行用户模块代码重构的需求分析和设计
通知你确认重构需求分析和设计  # 通知你确认重构需求分析和设计
```

### 4.2 重构开发与单元测试
```bash
# 你的确认：确认重构需求分析和设计
# 我的操作如下：
代码重构  # 开始用户模块代码的重构
代码检查和单元测试  # 进行代码检查和运行单元测试
通知你重构完成  # 报告你用户模块代码重构完成
```

### 4.3 重构集成测试与代码提交，版本更新
```bash
# 你的下命令：进行最终集成和回归测试
# 我的操作如下：
# 自动构建项目  # 构建项目验证
# 自动进行回归测试  # 运行整体功能测试
# 自动运行集成测试  # 运行模块间交互的测试
git checkout main  # 切换到主分支
git merge refactor/用户模块  # 合并重构分支
git add .  # 添加所有文件到暂存区
git commit -m "refactor: 重构用户模块代码"  # 提交代码
git tag v1.2.2  # 更新版本标签
```

### 4.2 重构代码
```bash
# 我自动进行代码重构
# 我自动运行所有测试
```

### 4.3 重构完成
```bash
# 你说："重构完成了"
# 你进行最终检查和回归测试
# 你确认重构正确

# 我合并分支
git checkout main
git merge refactor/用户模块
```

## 5. 版本发布流程

### 5.1 准备发布
```bash
# 你的指令：准备发布 v1.2.0
# 我的操作如下：
# 自动检查所有测试通过  # 检查所有测试是否通过
# 自动构建发布包  # 构建发布版本
# 自动验证构建结果  # 验证构建是否成功
```

### 5.2 发布版本及代码提交
```bash
# 你的指令：发布版本验证成功
# 我的操作如下：
git checkout main  # 切换到主分支
git merge develop  # 合并开发分支到主分支
git add .  # 添加所有文件到暂存区
git commit -m "release: 发布 v1.2.0 版本"  # 提交代码
git tag v1.2.0  # 创建版本标签
git push origin main --tags  # 推送到远程仓库
```

## 6. 协作规范

### 6.1 分支命名规范
- `feature/功能名称` - 新功能开发
- `bugfix/问题描述` - Bug 修复  
- `refactor/优化描述` - 代码重构
- `hotfix/紧急修复` - 紧急线上修复

### 6.2 提交信息规范
```
type: 描述

类型包括：
- feat: 新功能
- fix: Bug 修复
- refactor: 代码重构
- perf: 性能优化
- test: 测试相关
- docs: 文档更新
```

### 6.3 测试规范
- 单元测试：每个函数
- 集成测试：模块间交互
- 回归测试：整体功能

## 7. 质量保证流程

### 7.1 自动化检查

**前端项目（Node.js/Vue/React）**
```bash
# 我的操作如下：
npm test              # 运行 Jest/Vitest 单元测试
npm run lint          # ESLint 代码风格检查
npm run build         # 构建生产版本
npx playwright test   # Playwright 端到端测试
```

**后端项目（Go语言）**
```bash
# 我的操作如下：
go test ./...         # 运行单元测试
go vet ./...          # 代码静态检查
go build -o app       # 编译构建
```

**后端项目（Python）**
```bash
# 我的操作如下：
pytest                # 运行 pytest 单元测试
pylint .              # 代码风格检查
python -m py_compile  # 语法检查
```

### 7.2 人工验证

**前端项目**
```bash
# 你的操作如下：
npm run dev           # 本地开发运行
浏览器手动测试         # 功能验证
回归测试              # 整体功能验证
```

**后端项目（Go/Python）**
```bash
# 你的操作如下：
本地启动服务           # 启动服务进行测试
API 接口测试           # 使用 Postman/curl 测试
回归测试              # 整体功能验证
```

## 8. 版本管理

### 8.1 版本规范
```
v主版本号.次版本号.修订号
示例：v1.2.0
```

### 8.2 版本类型
- **主版本**：重大架构变更
- **次版本**：新功能模块
- **修订号**：Bug 修复、小优化

## 9. 备份和恢复

### 9.1 本地备份
```bash
# 我的操作如下：
cp -r .git backup/  # 备份 Git 仓库
```

### 9.2 版本回退
```bash
# 我的操作如下：
git reset --hard 版本号  # 回退到指定版本
```

### 9.2 版本回退
```bash
# 恢复到指定版本
git reset --hard 版本号  # 回退到指定版本
```

## 10. 协作流程图

```
你（需求）→ 我（自动化）→ 你（验证）→ 我（合并）
    ↓             ↓             ↓           ↓
功能需求 → 测试运行 → 回归检查 → 版本控制 → 发布完成
```

## 11. 完成标准

**只有当你确认**：
- ✅ 功能满足需求
- ✅ 所有测试通过
- ✅ 回归测试验证
- ✅ 用户体验良好

**才算真正完成。**

## 12. 常用测试工具说明

### 12.1 前端自动化测试工具

**Jest**
- 用途：JavaScript/TypeScript 单元测试
- 适用：React、Vue、前端项目 ✅最常用
- 命令：`npm test` 或 `npx jest`

**Vitest**
- 用途：现代化的单元测试框架，速度快
- 适用：Vite 项目
- 命令：`npx vitest`

**Playwright**
- 用途：端到端（E2E）测试，模拟真实用户操作
- 适用：多浏览器自动化测试（Chrome、Firefox、WebKit）
- 特点：支持移动端模拟、API 测试、截图对比
- 命令：`npx playwright test`

**Puppeteer**
- 用途：Chrome/Chromium 自动化测试
- 适用：浏览器操作、截图、PDF 生成、爬虫
- 特点：主要针对 Chrome，但也支持 Firefox
- 命令：`npx puppeteer`

**Cypress**
- 用途：端到端测试，开发友好
- 适用：Web 应用测试
- 特点：自带可视化界面，调试方便
- 命令：`npx cypress open`

**Selenium**（很少用，了解即可）
- 用途：跨浏览器自动化测试
- 适用：多语言、多浏览器
- 特点：老牌工具，配置复杂，现在较少使用
- 命令：`selenium-server`

### 12.2 什么是端到端（E2E）测试

**端到端测试的定义**
- 模拟真实用户的完整操作流程
- 从开始到结束测试整个应用
- 涵盖前端 → 后端 → 数据库

**对比**

| 测试类型 | 范围 | 速度 | 例子 |
|---------|------|------|------|
| **单元测试** | 函数/组件 | 快 | 测试一个登录函数 |
| **集成测试** | 模块交互 | 中 | 测试登录模块和用户模块 |
| **端到端测试** | 完整流程 | 慢 | 测试用户从登录到下单全流程 |

**端到端测试的例子**
```bash
# 模拟用户操作流程
1. 打开浏览器
2. 输入网址
3. 点击登录按钮
4. 输入用户名密码
5. 点击提交
6. 验证跳转到首页
7. 验证用户信息显示正确
```

**什么时候用端到端测试**
- 关键业务流程（登录、支付、下单）
- 用户操作频繁的功能
- 需要验证整体交互

**什么时候不用**
- 简单的工具函数
- 单元测试能覆盖的逻辑
- 频繁变更的 UI

### 12.3 后端自动化测试工具

**Go 测试框架**
- 用途：Go 语言单元测试
- 命令：`go test ./...`

**Pytest**
- 用途：Python 单元测试
- 命令：`pytest`

**unittest**
- 用途：Python 标准单元测试
- 命令：`python -m unittest`

### 12.3 代码检查工具

**ESLint**
- 用途：JavaScript/TypeScript 代码风格检查
- 命令：`npm run lint`

**Prettier**
- 用途：代码格式化
- 命令：`npx prettier --write .`

**go vet**
- 用途：Go 代码静态检查
- 命令：`go vet ./...`

**pylint**
- 用途：Python 代码风格检查
- 命令：`pylint .`

## 13. 包管理工具说明

### 13.1 Node.js 包管理工具对比

| 工具 | 安装命令 | 特点 | 推荐场景 |
|------|---------|------|---------|
| **npm** | `npm install` | 默认工具，依赖多占用空间大 | 快速原型 |
| **pnpm** | `pnpm install` | 全局缓存，硬链接，节省空间 ✅推荐 | 所有项目 |
| **yarn** | `yarn install` | Facebook 开发，速度快 | 团队协作 |

### 13.2 pnpm 的优势

**节省空间**
- 全局缓存存储依赖
- 项目间共享依赖
- 占用空间减少 50%-70%

**安装速度快**
- 并行下载
- 硬链接复制

**命令对比**
```bash
# npm
npm install           # 安装依赖
npm install 包名      # 安装单个包
npm update           # 更新依赖

# pnpm（推荐使用）✅
pnpm install         # 安装依赖
pnpm add 包名        # 安装单个包
pnpm update         # 更新依赖

# yarn
yarn install         # 安装依赖
yarn add 包名        # 安装单个包
yarn upgrade        # 更新依赖
```

### 13.3 node_modules 目录说明

**什么是 node_modules**
- 存放项目依赖的目录
- 每个项目独立一份
- 包含所有下载的第三方包

**为什么每个项目都要有**
- 版本隔离（不同项目可能用不同版本）
- 依赖嵌套（包里面还有包）
- 避免版本冲突

**占用空间问题**
- npm：每个项目独立存储，占用空间大
- pnpm：硬链接到全局缓存，实际占用空间小
- yarn：类似 npm

**pnpm 缓存位置**
| 系统 | 缓存位置 |
|------|---------|
| Windows | `C:\Users\用户名\AppData\Local\pnpm` |
| Linux | `~/.cache/pnpm` |
| macOS | `~/.cache/pnpm` |

**会不会被清理**
- 不会自动删除
- 手动删除后 pnpm 会重新下载
- 建议定期备份缓存目录

### 13.4 使用规范

**我们项目的规范**
- ✅ 使用 `pnpm install` 安装依赖
- ✅ 避免使用 `npm install`
- ✅ 减少磁盘空间占用

**pnpm 安装和使用**
```bash
# 全局安装 pnpm
npm install -g pnpm

# 或者用 winget 安装（Windows）
winget install pnpm

# 进入项目目录
cd 项目目录

# 安装依赖
pnpm install

# 添加依赖
pnpm add 包名

# 更新依赖
pnpm update

# 运行测试
pnpm test
```

## 14. 代码重构说明

### 14.1 什么时候需要重构

**代码重复**
- 相同代码出现 3 次以上
- 复制粘贴代码过多

**函数/类过大**
- 一个函数超过 50-100 行
- 一个类职责过多

**命名不清晰**
- 变量名含义不明
- 函数名不能表达用途

**难以测试**
- 函数依赖过多
- 耦合度太高

**性能问题**
- 代码执行效率低
- 算法可以优化

**技术债务**
- 代码风格不统一
- 缺乏必要注释

### 14.2 重构的最佳时机

**推荐重构**
- 新功能开发前
- Bug 修复过程中
- 代码审查后

**不建议重构**
- 项目即将发布
- 没有测试覆盖
- 对代码不熟悉

### 14.3 重构原则

- 小步迭代
- 每次只改一点
- 保证测试通过
- 随时可以提交

**我们的协作优势**：
- 你专注业务逻辑
- 我保障技术质量
- 自动化减少错误
- 协作更高效

这个流程涵盖了从初始化到发布的完整过程，确保了代码质量和协作效率。

**更新时间**: 2026-02-04 23:22:50