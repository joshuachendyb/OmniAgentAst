# OpenCode的金牌Skill-DCP解析和实战经验

**创建时间**: 2026-02-11 13:48:21
**更新时间**: 2026-02-11 13:58:05
**存放位置**: D:\2bktest\MDview\doc\
**版本**: v1.1

---

## 1 概要介绍 【DCP是什么】2026-02-11 13:48:21

### 1.1 OpenCode是什么

OpenCode是一个基于大语言模型的编程助手工具，通过命令行界面与用户交互，能够执行文件操作、代码编写、系统命令等任务。

### 1.2 DCP是什么

**DCP（Dynamic Context Pruning）** 是OpenCode的动态上下文修剪插件，用于管理和优化对话上下文。

### 1.3 为什么说DCP是OpenCode的金牌Skill

| 原因 | 说明 |
|------|------|
| **解决核心问题** | 会话历史过长时，大模型反应会变慢 |
| **节省时间** | 减少上下文冗余，提升响应速度 |
| **节省金钱** | 减少token消耗，降低API调用成本 |
| **延长会话寿命** | 避免因上下文爆满而无法继续使用 |

### 1.4 为什么会话变长会变慢

```
会话历史变长 → 上下文增大 → 大模型需要处理更多内容 → 响应变慢

极端情况：
上下文接近200K上限 → 大模型处理困难 → 可能不反应 → 需要开新会话
```

**原因**：大模型每次回复都需要重新处理整个上下文，上下文越长，处理时间越长。

### 1.5 DCP的组成

DCP包含**6个工具/策略**，分工协作：

| 工具/策略 | 类型 | 作用 | permission控制 |
|----------|------|------|----------------|
| **prune** | 可配置工具 | 删除指定工具输出 | allow/ask/deny |
| **distill** | 可配置工具 | 精炼提取核心信息 | allow/ask/deny |
| **compress** | 可配置工具 | 压缩上下文内容 | allow/ask/deny |
| **deduplication** | 自动策略 | 去除重复的工具调用 | enabled: true/false |
| **supersedeWrites** | 自动策略 | 覆盖旧写入记录 | enabled: true/false |
| **purgeErrors** | 自动策略 | 清理错误记录 | enabled: true/false |

**permission含义**：
- `allow` = 自动运行，无需确认
- `ask` = 运行前先询问用户
- `deny` = 禁止运行

**分类**：
- **可配置工具（3个）**：prune、distill、compress → 根据permission决定是否自动运行
- **自动策略（3个）**：deduplication、supersedeWrites、purgeErrors → 通过enabled开关控制

---

## 2 DCP策略核心概念详解 【深入理解】2026-02-11 13:48:21

### 2.1 上下文结构图

```
┌─────────────────────────────────────────┐
│            上下文（200K）                 │
├─────────────────────────────────────────┤
│  用户消息                                │
│  AI回复                                  │
│  ┌───────────────────────────────────┐  │
│  │ 工具调用记录                        │  │
│  │  - read: xxx                       │  │
│  │  - write: xxx  ← 写入记录          │  │
│  │  - edit: xxx                       │  │
│  │  - bash: xxx                       │  │
│  └───────────────────────────────────┘  │
└─────────────────────────────────────────┘
```

**说明**：
- **上下文** = 整个对话的"记忆容量"（200K tokens）
- **工具调用记录** = 上下文中的一部分，记录了所有工具操作
- **写入记录** = 工具调用记录的子集，专门记录文件写入操作

---

### 2.2 supersedeWrites（覆盖写入）详解

#### 什么是写入记录？

```
对话上下文 = 你的消息 + 我的回复 + 工具调用记录
                                    ↓
                          ┌─────────────────────────┐
                          │  工具调用记录（会占用上下文） │
                          ├─────────────────────────┤
                          │ read: 文件内容          │
                          │ write: 写入了什么内容    │  ← 这就是"写入记录"
                          │ bash: 命令输出          │
                          │ edit: 修改了什么         │
                          └─────────────────────────┘
```

#### 举例说明

```
我说：读取A.txt
→ 工具调用：read A.txt
→ 上下文中增加一条记录：read A.txt 的内容

我说：写入B.txt
→ 工具调用：write B.txt
→ 上下文中增加一条记录：write B.txt 写入了xxx内容  ← 这就是写入记录
```

#### supersedeWrites 的作用

```
场景：我多次修改同一个文件

第1次：edit A.txt（改了第10行）
第2次：edit A.txt（改了第20行）
第3次：edit A.txt（改了第30行）

上下文中的记录：
- edit A.txt 第1次的完整内容  ← 占用上下文
- edit A.txt 第2次的完整内容  ← 占用上下文
- edit A.txt 第3次的完整内容  ← 占用上下文

如果 supersedeWrites = true：
  → 只保留第3次的记录，删除前2次
  → 节省上下文空间
  → 但丢失了修改历史

如果 supersedeWrites = false：
  → 3次记录都保留
  → 占用更多上下文
  → 但可以追溯修改历史
```

---

### 2.3 purgeErrors（清理错误）详解

#### 错误是什么？

```
错误 = 工具调用失败时的错误信息

例如：
- read: 文件不存在 → 产生错误记录
- write: 权限不足 → 产生错误记录
- bash: 命令执行失败 → 产生错误记录
- edit: 找不到oldString → 产生错误记录
```

#### purgeErrors 的作用

```
场景：调试时多次失败

第1轮：read A.txt → 失败，文件不存在
第2轮：read B.txt → 失败，权限不足
第3轮：read C.txt → 成功

上下文中的错误记录：
- 第1轮的错误信息
- 第2轮的错误信息

如果 purgeErrors 开启：
  → 几轮对话后自动删除这些错误记录
  → 节省上下文空间
  → 但丢失了错误历史

如果 purgeErrors 关闭：
  → 错误记录一直保留
  → 占用上下文
  → 但可以回顾调试过程
```

#### 为什么要保留错误？

| 保留原因 | 说明 |
|---------|------|
| **调试追溯** | 可以回顾之前为什么失败 |
| **学习改进** | 知道哪些方法行不通 |
| **问题分析** | 错误信息可能包含重要线索 |

---

### 2.4 deduplication（去重）详解

#### 什么是重复的工具调用？

```
场景：多次读取同一个文件

第1次：read A.txt → 返回文件内容
第2次：read A.txt → 返回相同内容（重复）
第3次：read A.txt → 返回相同内容（重复）

如果 deduplication = true：
  → 只保留最新的调用记录
  → 删除之前的重复调用
  → 节省上下文空间

如果 deduplication = false：
  → 所有调用记录都保留
  → 浪费上下文空间
```

---

### 2.5 三个策略对比总结

| 策略 | 处理什么 | 开启后 | 关闭后 | 建议 |
|------|---------|--------|--------|------|
| **deduplication** | 重复的工具调用 | 只保留最新一次 | 保留所有重复调用 | ✅ 开启 |
| **supersedeWrites** | 文件写入记录 | 只保留最新写入 | 保留所有写入历史 | ❌ 关闭 |
| **purgeErrors** | 工具调用错误 | N轮后自动清理 | 保留所有错误记录 | ✅ 开启，延长到15轮 |

---

### 2.6 写入记录 vs 上下文的关系

```
┌─────────────────────────────────────────┐
│            上下文（200K）                 │
├─────────────────────────────────────────┤
│  用户消息                                │
│  AI回复                                  │
│  ┌───────────────────────────────────┐  │
│  │ 工具调用记录                        │  │
│  │  - read: xxx                       │  │
│  │  - write: xxx  ← 写入记录          │  │ ← 写入记录是上下文的子集
│  │  - edit: xxx                       │  │
│  │  - bash: xxx                       │  │
│  └───────────────────────────────────┘  │
└─────────────────────────────────────────┘
```

| 概念 | 说明 |
|------|------|
| **上下文** | 整个对话的"记忆容量"（200K tokens） |
| **写入记录** | 上下文中的一部分，记录了文件操作的内容 |
| **关系** | 写入记录是上下文的子集 |

---

### 2.7 当前配置及理由

```json
{
  "deduplication": { "enabled": true },   // ✅ 保留：去重合理
  "supersedeWrites": { "enabled": false }, // ✅ 关闭：保留写入历史
  "purgeErrors": { "enabled": true, "turns": 10 } // ✅ 保留：10轮后清理
}
```

| 策略 | 状态 | 理由 |
|------|------|------|
| deduplication | 开 | 相同操作去重，节省空间，不会丢失重要信息 |
| supersedeWrites | 关 | 保留修改历史，方便调试和追溯问题 |
| purgeErrors | 开 | 错误信息保留10轮，够用了，太久也没意义 |

---

## 3 Prune工具详解 【手动工具】2026-02-11 13:48:21

### 3.1 什么是Prune

Prune是DCP的手动工具之一，用于删除对话中不再需要的工具输出，释放上下文空间。

### 3.2 Prune的工作原理

| 行为 | 说明 |
|------|------|
| **删除内容** | 只删除对话上下文中的工具输出显示 |
| **不删除文件** | 不会删除实际存放在磁盘上的数据文件 |

### 3.3 重要发现：permission不控制自动策略

| 配置项 | 作用 | 受permission控制？ |
|--------|------|------------------|
| `tools.prune` | 手动调用prune工具 | ✅ 受控制 |
| `tools.distill` | 手动调用distill工具 | ✅ 受控制 |
| `tools.compress` | 手动调用compress工具 | ✅ 受控制 |
| `strategies.deduplication` | **自动去重** | ❌ 不受控制 |
| `strategies.supersedeWrites` | **自动删除被覆盖的写入** | ❌ 不受控制 |
| `strategies.purgeErrors` | **自动清理错误** | ❌ 不受控制 |

**核心结论**：

> `permission` 只控制**手动调用工具**时的行为，**自动策略独立运行，不受permission控制！**

---

## 4 不同工具的Prune风险 【工具分类】2026-02-11 13:48:21

### 4.1 安全的（保存到磁盘）

| 工具 | 保存位置 | Prune后影响 |
|------|---------|-------------|
| `webfetch` | `tool-output/` 目录 | ✅ 无影响，可重新读取 |
| `google_search` | `tool-output/` 目录 | ✅ 无影响，可重新读取 |
| API调用结果 | `tool-output/` 目录 | ✅ 无影响 |

**说明**：`webfetch`和`google_search`的区别：
- `webfetch`：已知具体URL，直接获取网页内容
- `google_search`：搜索关键词，返回搜索结果和来源链接
- 两者都会保存到磁盘，**都是安全的**

### 4.2 有风险的（只在内存）

| 工具 | 数据位置 | Prune后影响 |
|------|---------|-------------|
| `read` | 内存 | ⚠️ **内容丢失** |
| `bash` | 内存 | ⚠️ **输出丢失** |
| `grep/glob` | 内存 | ⚠️ **结果丢失** |

### 4.3 风险场景示例

```
1. read 读取了重要配置文件
2. 还没处理完，被 prune 删掉了
3. 后续想引用那个配置内容 → 找不到了！
```

---

## 5 避免Prune干扰的方法 【最佳实践】2026-02-11 13:48:21

### 5.1 三种避免方法

| 方法 | 操作 | 适用场景 |
|------|------|---------|
| **方法1: distill** | 用 `distill` 精炼核心信息 | 长内容，只需保留关键点 |
| **方法2: 写文件** | 写入临时文件保存 | 需要完整内容后续使用 |
| **方法3: 延迟prune** | 任务完成前不prune相关输出 | 还在处理中的内容 |

### 5.2 工作流程建议

```
正确流程：
1. 获取信息（read/bash/grep）
2. 立即处理或保存关键信息
3. 确认不再需要原始输出后，再prune
4. 不要在任务中途prune可能还需要的内容
```

### 5.3 判断是否可以Prune

| 情况 | 是否可以Prune |
|------|:------------:|
| 信息已处理完毕 | ✅ 可以 |
| 已用distill精炼 | ✅ 可以 |
| 已写入文件保存 | ✅ 可以 |
| 任务还在进行中 | ❌ 不可以 |
| 后续可能还要引用 | ❌ 不可以 |
| 不确定是否还需要 | ❌ 先不prune |

---

## 6 实际案例 【本会话经验】2026-02-11 13:48:21

### 6.1 安全案例

```
webfetch 获取 OpenRouter API 数据
  ↓
自动保存到 tool-output/tool_c4a6fb58b001tcWLUvk3o9aFdx
  ↓
被 prune 删除了对话中的显示
  ↓
但文件还在磁盘上，可以重新读取 ✅
```

### 6.2 图片生成被打劫案例（真实）

**问题描述**：
在生成图片时，有一种生成方法是调用工具先生成图片数据，然后数据刚生成就被prune打劫删除了。

**问题流程**：
```
调用图片生成工具
  ↓
生成图片数据（base64或二进制）
  ↓
数据量大，触发prune机制
  ↓
图片数据被删除 ❌
  ↓
后续处理找不到图片数据
```

**解决方案**：

| 方案 | 说明 |
|------|------|
| **方案1** | 图片生成后立即写入文件保存 |
| **方案2** | 生成时指定输出文件路径 |
| **方案3** | 在图片生成任务完成前禁用自动prune |

---

## 7 大模型主动避免被打劫的方法 【AI操作规范】2026-02-11 13:48:21

**重要**：用户无法控制prune，大模型在调度工具时必须主动避免被打劫。

### 7.1 核心原则（头条铁规）

> **防DCP Prune打劫、截断数据流**：任务未完成不删除工具输出；关联操作连续完成不被打断；大数据（图片、长文本）获取后立即写文件保存。

### 7.2 大模型必须遵守的操作规范

| 规范 | 说明 |
|------|------|
| **规范1: 立即处理** | 获取数据后立即处理，不要等到后续步骤 |
| **规范2: 先保存再prune** | 重要数据先写入文件或用distill精炼，再考虑prune |
| **规范3: 任务完成前不prune** | 当前任务还在进行中，不要prune相关输出 |
| **规范4: 图片数据特殊处理** | 图片生成后必须立即写入文件保存 |
| **规范5: 大数据量警惕** | 预估输出量大时，优先考虑保存到文件 |

### 7.3 风险识别清单

| 情况 | 风险等级 | 处理方法 |
|------|:--------:|---------|
| 输出量可能很大 | ⚠️ 高 | 优先写入文件 |
| 需要多步骤处理 | ⚠️ 高 | 中间数据保存 |
| 图片/二进制数据 | ⚠️ 高 | 立即写文件 |
| 需要后续引用 | ⚠️ 中 | 用distill或写文件 |
| 一次性使用 | ✅ 低 | 可以prune |

### 7.4 简记口诀

```
webfetch 安全放心
read/bash 要小心
任务没完别prune
重要内容先保存
大数据量写文件
图片生成立即存
```

---

**更新时间**: 2026-02-11 13:48:21
