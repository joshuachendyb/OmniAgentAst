# OmniAgentAst. 桌面版 - 系统设计方案

**【版本】v1.0 : 2026-02-15 11:17:09 : 创建文档**
**【版本】v1.1 : 2026-02-15 12:35:00 : 简化名称，优化架构设计

---

## 1. 产品定位与愿景

### 1.1 核心定位

OmniAgentAst. 桌面版是一款**本地运行的AI智能助手**，专为Windows桌面环境设计，能够在用户的电脑上自主执行任务、管理信息、协助工作。

**一句话描述**：*你的电脑里住进了一个聪明的数字助手，它会用你的软件、处理你的文件、帮你完成各种电脑上的繁琐工作。*

### 1.2 目标用户

| 用户类型 | 典型场景 | 核心需求 |
|---------|---------|---------|
| **效率工作者** | 程序员、设计师、写作者 | 自动化重复操作，批量处理文件 |
| **信息管理者** | 研究员、学生、知识工作者 | 整理笔记、搜索信息、归档资料 |
| **电脑小白** | 不熟悉复杂操作的用户 | 用自然语言让电脑做事 |

### 1.3 与原版 AI_OSShell_v2 的关系

**继承**：
- ReAct智能循环架构
- 工具调用机制
- 本地命令执行能力

**升级**：
- 桌面GUI替代Web界面
- 配置化管理替代硬编码
- 安全确认机制
- 持久化存储

---

## 2. 系统架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                    用户界面层 (UI Layer)                      │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │
│  │  主聊天窗口   │  │  系统托盘     │  │  快捷指令    │       │
│  │  (对话交互)   │  │  (后台常驻)   │  │  (快捷键)    │       │
│  └──────────────┘  └──────────────┘  └──────────────┘       │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                   核心引擎层 (Core Engine)                    │
│  ┌─────────────────┐  ┌─────────────────┐                   │
│  │   AI Agent      │  │   任务管理器     │                   │
│  │   (ReAct循环)   │  │   (队列+状态)    │                   │
│  └─────────────────┘  └─────────────────┘                   │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                    工具层 (Tools Layer)                       │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐       │
│  │ 文件操作  │ │ 系统命令  │ │ 浏览器   │ │ 应用程序  │       │
│  │ 读写/管理 │ │ 执行/脚本 │ │ 自动化   │ │ 控制     │       │
│  └──────────┘ └──────────┘ └──────────┘ └──────────┘       │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                   数据层 (Data Layer)                         │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │
│  │  对话历史     │  │  配置文件     │  │  知识库      │       │
│  │  SQLite      │  │  YAML/JSON   │  │  本地向量库   │       │
│  └──────────────┘  └──────────────┘  └──────────────┘       │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 技术栈选择

| 层级 | 技术选型 | 选择理由 |
|------|---------|---------|
| **桌面UI** | Tauri (Rust) + React | 体积小(几MB)、性能好、现代Web技术 |
| **后端核心** | Python 3.11+ | AI生态完善、现有代码可复用 |
| **AI接口** | Claude API (默认) | 支持多模态、工具调用友好 |
| **数据存储** | SQLite + Local Vector DB | 零配置、单文件、易备份 |
| **配置管理** | YAML | 人类可读、易编辑、支持注释 |

### 2.3 混合架构设计（Plan-and-Execute + ReAct + Reflection）

#### 2.3.1 架构核心思想

针对Windows桌面环境的复杂性（软件千差万别、操作不确定性强），采用**三层混合架构**，取各架构之长：

| 架构层 | 采用模式 | 解决问题 | 占比 |
|--------|---------|---------|------|
| **规划层** | Plan-and-Execute | 任务分解、批量执行 | 60% |
| **执行层** | ReAct | 动态调整、错误恢复 | 30% |
| **优化层** | Reflection | 质量提升、复杂修复 | 10% |

#### 2.3.2 三层架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                      用户输入层                                  │
│              "帮我整理桌面并截图归档"                             │
└──────────────────────────┬──────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────────┐
│  第一层：Planner (计划生成器) - Plan-and-Execute                  │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │ 1. 理解用户意图 → 2. 分解任务步骤 → 3. 生成执行计划         │   │
│  │                                                          │   │
│  │ 计划示例：                                               │   │
│  │ Step 1: 扫描桌面文件                                     │   │
│  │ Step 2: 按类型分类(图片→截图文件夹)                        │   │
│  │ Step 3: 截图当前桌面状态                                  │   │
│  │ Step 4: 将截图保存到归档文件夹                             │   │
│  └──────────────────────────────────────────────────────────┘   │
└──────────────────────────┬──────────────────────────────────────┘
                           ↓ 用户确认
┌─────────────────────────────────────────────────────────────────┐
│  第二层：Executor (执行器) - ReAct循环                           │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                                                          │   │
│  │   ┌─────────┐    ┌─────────┐    ┌─────────┐             │   │
│  │   │ 思考    │ →  │ 行动    │ →  │ 观察    │             │   │
│  │   │ (Thought)│    │ (Action)│    │ (Observe)│             │   │
│  │   └─────────┘    └─────────┘    └─────────┘             │   │
│  │        ↑                           │                     │   │
│  │        └───────────────────────────┘                     │   │
│  │                                                          │   │
│  │ 每个Step独立循环，失败时自动重试（最多3次）                 │   │
│  └──────────────────────────────────────────────────────────┘   │
└──────────────────────────┬──────────────────────────────────────┘
                           ↓ 发现问题/质量不佳
┌─────────────────────────────────────────────────────────────────┐
│  第三层：Refiner (优化器) - Reflection反思                       │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                                                          │   │
│  │ 触发条件：                                               │   │
│  │ • 步骤连续失败2次                                        │   │
│  │ • 结果不符合预期                                         │   │
│  │ • 用户反馈"不对"                                         │   │
│  │                                                          │   │
│  │ 处理流程：                                               │   │
│  │ 1. 分析失败原因                                          │   │
│  │ 2. 生成修复方案                                          │   │
│  │ 3. 重新执行（回到Executor）                                │   │
│  │                                                          │   │
│  └──────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

#### 2.3.3 工作流程示例

**场景：用户说"打开Chrome并搜索今天的新闻"**

```
【第1层 - Planner】
AI分析：这是一个"打开应用+浏览器操作"任务
生成计划：
  Plan Step 1: 查找Chrome进程或启动Chrome
  Plan Step 2: 等待Chrome窗口出现
  Plan Step 3: 聚焦Chrome地址栏
  Plan Step 4: 输入"今天的新闻"
  Plan Step 5: 按回车搜索

用户确认：[执行] [查看详情] [取消]
用户点击：执行

【第2层 - Executor - Step 1】
ReAct循环：
  Thought: 需要先检查Chrome是否已运行
  Action: list_windows() 查找Chrome
  Observation: 未找到Chrome窗口
  
  Thought: Chrome未运行，需要启动
  Action: run_shell("start chrome")
  Observation: 命令执行成功，进程已启动
  
  Thought: 等待窗口出现
  Action: sleep(2)
  Observation: Chrome窗口已出现
  
✓ Step 1 完成

【第2层 - Executor - Step 4】
ReAct循环：
  Thought: 需要聚焦地址栏，按Ctrl+L
  Action: hotkey(['ctrl', 'l'])
  Observation: 失败，焦点不在Chrome
  
  Thought: 先切换到Chrome窗口
  Action: switch_window('Chrome')
  Observation: 成功
  
  Thought: 再试聚焦地址栏
  Action: hotkey(['ctrl', 'l'])
  Observation: 成功，地址栏已选中
  
  Thought: 输入搜索词
  Action: type_text("今天的新闻")
  Observation: 成功
  
✓ Step 4 完成（虽然中间失败1次，但自动恢复了）

【第3层 - Refiner】（本例未触发）
如果Step 4连续失败2次 → 进入Refiner分析原因
→ 可能是权限问题 → 建议以管理员重试
→ 或更换执行方式

【结果】
✓ 所有步骤完成，用户看到搜索结果
```

#### 2.3.4 各架构模式详解

**Plan-and-Execute（规划层）**

```python
class Planner:
    """任务规划器：一次性生成完整计划"""
    
    def generate_plan(self, user_input: str) -> ExecutionPlan:
        # 调用AI生成计划
        response = self.ai.complete(
            prompt=f"""
            将用户任务分解为可执行步骤：
            用户请求：{user_input}
            
            可用工具：{self.tools_description}
            
            输出格式：
            1. 步骤描述
            2. 预期使用的工具
            3. 预期结果
            4. 是否关键步骤（失败需要人工干预）
            """
        )
        return self.parse_plan(response)
```

**优势**：
- 用户提前知道要做什么（透明）
- 减少API调用次数（成本低）
- 批量执行（速度快）

**ReAct（执行层）**

```python
class ReActExecutor:
    """ReAct执行器：每步动态调整"""
    
    def execute_step(self, step: Step, max_retries=3) -> Result:
        for attempt in range(max_retries):
            # 思考
            thought = self.think(step, context)
            
            # 行动
            action = self.decide_action(thought)
            observation = self.execute_action(action)
            
            # 检查成功
            if self.is_success(observation):
                return Result.success(observation)
            
            # 记录失败，进入下次重试
            context.add_attempt(attempt, thought, action, observation)
        
        # 超过重试次数，标记失败
        return Result.failure(context)
```

**优势**：
- 环境变化可适应
- 单步失败可恢复
- 适合不确定性的Windows环境

**Reflection（优化层）**

```python
class Refiner:
    """反思优化器：深度分析和修复"""
    
    def refine(self, failed_task: Task) -> FixStrategy:
        # 分析失败模式
        analysis = self.analyze_failure(failed_task)
        
        # 生成修复策略
        strategy = self.ai.complete(
            prompt=f"""
            任务执行失败，分析原因并提供修复方案：
            
            原始任务：{failed_task.description}
            失败步骤：{failed_task.failed_step}
            错误信息：{failed_task.error}
            历史尝试：{failed_task.attempts}
            
            请提供：
            1. 失败根因分析
            2. 新的执行策略
            3. 预防措施
            """
        )
        
        return strategy
```

**触发条件**：
```python
REFINER_TRIGGERS = {
    "consecutive_failures": 2,      # 同一任务连续失败2次
    "user_rejection": True,          # 用户明确说"不对"
    "quality_score": "< 0.7",        # 结果质量评分低于0.7
    "unexpected_result": True        # 结果与预期差异过大
}
```

**优势**：
- 处理复杂异常情况
- 从失败中学习
- 提升长期成功率

#### 2.3.5 为什么这样设计？

**针对Windows桌面复杂性的解决方案**：

| Windows复杂性 | 架构应对策略 |
|--------------|-------------|
| **软件千差万别** | Plan-and-Execute提供统一规划，ReAct应对具体差异 |
| **GUI不确定** | ReAct实时观察调整，Reflection处理异常布局 |
| **权限问题** | Reflection分析失败原因，提示用户提升权限 |
| **操作有副作用** | 计划阶段用户确认，关键操作二次确认 |
| **用户随时干预** | 每层都可中断，Executor层可暂停重试 |

**性能与质量平衡**：

```
简单任务（80%）: Planner → Executor → 完成
                快，低成本

中等任务（15%）: Planner → Executor(有重试) → 完成
                稍慢，但成功率高

复杂任务（5%）: Planner → Executor(失败) → Refiner → Executor → 完成
               慢，但几乎都能解决
```

---

## 3. 核心功能设计

### 3.1 功能全景图

```
                    ┌─────────────────┐
                    │   OmniAgentAst. │
                    │     桌面版      │
                    └────────┬────────┘
                             │
        ┌────────────────────┼────────────────────┐
        │                    │                    │
        ▼                    ▼                    ▼
┌───────────────┐   ┌───────────────┐   ┌───────────────┐
│   智能对话     │   │   工具执行     │   │   个人知识    │
│               │   │               │   │               │
│ • 自然语言交互 │   │ • 文件操作     │   │ • 文档理解    │
│ • 上下文记忆   │   │ • 命令执行     │   │ • 本地搜索    │
│ • 多轮任务     │   │ • 应用控制     │   │ • 知识问答    │
└───────────────┘   │ • 浏览器自动化 │   └───────────────┘
                    │ • 剪贴板管理   │
                    └───────────────┘
```

### 3.2 功能模块详解

#### 3.2.1 智能对话 (Chat)

**核心能力**：
- 自然语言理解用户意图
- 多轮对话保持上下文
- 自动规划任务步骤

**交互方式**：
```
用户: "帮我整理桌面，把截图移到'截图'文件夹"
Agent: "我来帮你整理桌面文件。我发现了以下内容：
       - 12个截图文件 (PNG/JPG)
       - 3个文档文件
       准备将截图移动到 ~/Desktop/截图/，确认吗？ [确认] [取消]"
用户: "确认"
Agent: "✓ 已完成！移动了12个文件到 ~/Desktop/截图/"
```

#### 3.2.2 文件助手 (File Assistant)

**支持操作**：
| 操作类型 | 示例指令 | 实现方式 |
|---------|---------|---------|
| 文件查找 | "找到所有上周下载的PDF" | os.walk + 时间过滤 |
| 批量重命名 | "把这些图片按日期重命名" | 正则 + os.rename |
| 文件整理 | "按类型把下载文件夹分类" | 分类规则 + shutil.move |
| 内容提取 | "总结这个文件夹里的文档" | 读取 + AI摘要 |
| 同步备份 | "把重要文件备份到移动硬盘" | rsync/shutil + 定时 |

#### 3.2.3 系统控制 (System Control)

**工具列表**：
```python
tools = [
    {
        "name": "run_shell",
        "description": "执行shell命令",
        "danger_level": "high",  # 需要确认
        "examples": ["ls -la", "mkdir new_folder"]
    },
    {
        "name": "type_text", 
        "description": "模拟键盘输入文本",
        "danger_level": "medium",
        "examples": ["自动填写表单", "快速输入常用语"]
    },
    {
        "name": "window_manage",
        "description": "窗口管理",
        "danger_level": "low",
        "examples": ["切换窗口", "调整窗口大小", "截图"]
    },
    {
        "name": "clipboard",
        "description": "剪贴板操作",
        "danger_level": "low", 
        "examples": ["复制", "粘贴", "历史记录"]
    }
]
```

#### 3.2.4 浏览器自动化 (Browser)

**能力范围**：
- 打开指定网页并提取信息
- 自动化填表和点击
- 网页内容截图保存
- 批量下载网页资源

**安全限制**：
- 仅操作用户明确指定的页面
- 敏感操作（登录、支付）需二次确认
- 不保存密码等敏感信息

#### 3.2.5 个人知识库 (Knowledge Base)

**设计理念**：
- 本地优先：所有数据保存在用户电脑
- 隐私保护：不上传云端，AI仅处理本地内容
- 渐进增强：用的越多，越懂用户

**功能特性**：
```
┌────────────────────────────────────────┐
│           个人知识库模块                │
├────────────────────────────────────────┤
│ 文档导入                                │
│ • PDF/Word/Markdown 自动解析           │
│ • 图片OCR文字提取                       │
│ • 网页内容保存                          │
├────────────────────────────────────────┤
│ 智能索引                                │
│ • 向量化存储 (本地Embedding)           │
│ • 全文搜索                              │
│ • 标签分类                              │
├────────────────────────────────────────┤
│ 知识问答                                │
│ • "我之前写的关于Python的笔记在哪？"     │
│ • "总结一下我下载的所有论文摘要"        │
│ • "对比文档A和文档B的观点差异"          │
└────────────────────────────────────────┘
```

---

## 4. 用户界面设计

### 4.1 界面布局

```
┌────────────────────────────────────────────────────────────┐
│  OmniAgentAst.                              [_] [□] [X]   │
├────────────┬───────────────────────────────────────────────┤
│            │                                               │
│  📁 文件    │    🤖 今天有什么可以帮你的？                   │
│  🖥️ 系统    │                                               │
│  🌐 浏览器  │    ┌─────────────────────────────────────┐   │
│  📚 知识库  │    │ 用户: 帮我整理下载文件夹               │   │
│  ⚙️ 设置    │    │                                       │   │
│            │    │ Agent: 好的，我发现下载文件夹有:        │   │
│ ───────────│    │ - 15个压缩包 (.zip/.rar)               │   │
│  💬 历史    │    │ - 23个文档 (.pdf/.doc)                 │   │
│  🔧 快捷    │    │ - 8个安装包 (.exe/.msi)                │   │
│            │    │                                       │   │
│            │    │ 建议按类型分3个文件夹存放，执行吗？      │   │
│            │    │ [执行] [查看详情] [取消]                │   │
│            │    └─────────────────────────────────────┘   │
│            │                                               │
│            │    ┌─────────────────────────────────────┐   │
│            │    │ > 帮我截图当前窗口并保存到桌面         │   │
│            │    └─────────────────────────────────────┘   │
│            │                    [发送]                     │
└────────────┴───────────────────────────────────────────────┘
```

### 4.2 交互设计原则

**1. 透明可见**
- Agent执行任何操作前，显示"准备做什么"
- 高危操作显示确认对话框
- 任务进度实时显示

**2. 随时接管**
- 任何时候可以打断Agent
- 提供"暂停"、"取消"按钮
- 错误时清晰说明原因

**3. 渐进授权**
```
风险等级    处理方式
─────────────────────────────
低风险      直接执行 (读取、查询)
中风险      通知用户 (修改文件、打开程序)  
高风险      必须确认 (删除、执行命令、网络操作)
极高风险    禁止执行 (格式化、系统关键操作)
```

---

## 5. 安全设计

### 5.1 本地安全模型

**核心原则**：用户完全控制自己的电脑，Agent只是协助者

```
┌──────────────────────────────────────┐
│          桌面版安全架构               │
├──────────────────────────────────────┤
│                                      │
│  用户 ←── 完全控制 ──→ 电脑系统       │
│   ↑                                  │
│   │ 授权                             │
│   ↓                                  │
│  Agent ←── 受限操作 ──→ 特定功能      │
│                                      │
│  安全边界: 用户明确授权 + 风险分级     │
│                                      │
└──────────────────────────────────────┘
```

### 5.2 风险分级与处理

| 等级 | 操作示例 | 处理方式 |
|------|---------|---------|
| **🟢 安全** | 读取文件、查询信息、打开应用 | 直接执行 |
| **🟡 注意** | 修改文件、创建文件夹、复制移动 | 通知用户，可撤销 |
| **🟠 谨慎** | 执行命令、删除文件、网络请求 | 必须确认，显示详情 |
| **🔴 危险** | 格式化、修改系统配置、执行脚本 | 禁止自动执行 |

### 5.3 隐私保护

**本地优先策略**：
- ✅ 所有数据本地存储
- ✅ 配置文件本地保存
- ✅ API Key仅保存在用户电脑
- ✅ 可选：对话历史不上传
- ✅ 知识库完全离线

**可选云端功能**（默认关闭）：
- 云端备份（用户主动开启）
- 跨设备同步（需账号系统）

---

## 6. 数据存储设计

### 6.1 存储结构

```
~/OmniAgentAst/
├── config/
│   ├── settings.yaml          # 用户配置
│   ├── api_keys.yaml          # API密钥 (加密存储)
│   └── shortcuts.yaml         # 快捷指令
│
├── data/
│   ├── conversations.db       # SQLite对话历史
│   ├── knowledge.db           # 知识库向量数据
│   └── cache/                 # 临时缓存
│
├── logs/
│   ├── app.log               # 运行日志
│   └── errors.log            # 错误日志
│
└── plugins/                  # 插件目录
    └── custom_tools/
```

### 6.2 配置管理

**settings.yaml 示例**：
```yaml
# 用户配置文件
version: "1.0"

# AI 配置
ai:
  provider: "anthropic"  # anthropic | openai | local
  model: "claude-3-5-sonnet-20241022"
  max_tokens: 4096
  temperature: 0.7
  
# 界面配置
ui:
  theme: "auto"  # light | dark | auto
  language: "zh-CN"
  minimize_to_tray: true
  global_shortcut: "Ctrl+Shift+O"

# 安全设置
security:
  confirm_destructive: true
  max_retry_attempts: 3
  shell_whitelist: []  # 允许的命令白名单
  shell_blacklist:     # 禁止的命令黑名单
    - "rm -rf /"
    - "format"
    - "mkfs"

# 知识库
knowledge:
  auto_index: true
  index_paths:
    - "~/Documents"
    - "~/Desktop"
  exclude_patterns:
    - "*.tmp"
    - "*.log"
```

---

## 7. 实现路线图

### 7.1 开发阶段

```
Phase 1: MVP核心 (4-6周)
────────────────────────────
[2周] 基础架构
  • Tauri + React 桌面框架
  • Python后端通信层
  • 基础UI界面
  
[2周] 核心功能  
  • 对话系统 + ReAct循环
  • 基础工具 (文件、命令)
  • 配置管理
  
[2周] 打磨优化
  • 错误处理
  • 性能优化
  • 安装打包

Phase 2: 功能增强 (4-6周)
────────────────────────────
[2周] 工具扩展
  • 浏览器自动化
  • 剪贴板管理
  • 窗口控制增强
  
[2周] 知识库
  • 文档导入解析
  • 向量索引
  • 语义搜索
  
[2周] 体验优化
  • 系统托盘
  • 全局快捷键
  • 插件系统初版

Phase 3: 生态完善 (4周)
────────────────────────────
• 插件市场
• 多模型支持
• 云端同步(可选)
• 移动端联动(可选)
```

### 7.2 技术债务规划

| 阶段 | 目标 | 可接受的临时方案 |
|------|------|----------------|
| MVP | 跑通核心流程 | 硬编码配置、简单错误处理 |
| 增强 | 功能完整 | 基础测试覆盖、手动配置 |
| 完善 | 生产就绪 | 完整测试、自动更新、文档 |

---

## 8. 与原版代码对比

| 方面 | AI_OSShell_v2 | OmniAgentAst. 个人版 |
|------|---------------|---------------------|
| **部署** | 本地Web服务 | 桌面应用 |
| **用户** | 单用户 | 单用户（个人） |
| **界面** | 浏览器页面 | 原生桌面GUI |
| **配置** | 硬编码Python | YAML配置文件 |
| **安全** | 无 | 风险分级确认 |
| **存储** | 内存 | SQLite持久化 |
| **工具** | 4个基础工具 | 10+工具 + 插件 |
| **知识库** | 无 | 本地向量库 |
| **扩展** | 改代码 | 插件系统 |

---

## 9. 下一步行动

### 9.1 立即开始（本周）

- [ ] **技术验证**
  - 搭建 Tauri + Python 通信原型
  - 验证 Claude API 工具调用
  - 测试跨平台兼容性

- [ ] **环境准备**
  - 安装 Rust + Tauri 依赖
  - 准备 Python 3.11+ 环境
  - 配置开发工具链

### 9.2 第一周目标

**可运行的原型**：
- [ ] 桌面窗口显示
- [ ] 输入框发送消息
- [ ] AI回复显示
- [ ] 至少1个工具（文件读取）

### 9.3 需要确认的问题

1. **UI框架**：确定用 Tauri 还是 Electron？
2. **AI模型**：先只支持 Claude，还是同时支持 OpenAI？
3. **操作系统**：优先 Windows，还是同时支持 Mac/Linux？
4. **Python打包**：用 PyInstaller 还是用户本地安装 Python？

---

## 10. 参考资源

### 10.1 相关文档

- `AI_OSShell_v2.py` - 原版代码
- `AI_OS_Agent_技术深度分析报告.md` - 技术分析
- `AI_OS_Agent_代码解析说明文档.md` - 代码详解

### 10.2 技术参考

| 技术 | 文档链接 |
|------|---------|
| Tauri | https://tauri.app/ |
| Claude API | https://docs.anthropic.com/ |
| ChromaDB | https://docs.trychroma.com/ |

---

**更新时间**: 2026-02-15 12:35:00

*本文档描述了 OmniAgentAst. 桌面版的完整设计方案，聚焦于Windows桌面环境，采用混合架构平衡效率与灵活性。*